---
title: "Lab 3: Keypad Scanner"
description: "Lab 3"
author: "Mayu Tatsumi"
date: "11/5/24"
categories:
  - labreport
draft: false
---

## Introduction
In this lab, the I/O pins on the FPGA board were interfaced with a 4x4 matrix keypad and a dual seven-segment display to display asynchronous user inputs in a synchronized fashion. A synchronizer was implemented for this purpose, along with a switch debouncer to prevent switch bounce. 

The goal of the lab was to program the FPGA so that the most recent input on the matrix keypad would display on the right of the dual display, and any subsequent inputs would update the display so that the older inputs would shift left and so on. The design of this code and FSMs utilized needed to be robust to be able to deal with various user inputs and expectations.

LINK: [E155 Lab 3 Instructions](https://hmc-e155.github.io/lab/lab3/)

## Design and Testing Methodology

The main FSM (in `keypad_scan` module) scans the 4x4 matrix keypad and also includes debouncing logic. It cycles through the rows by sequentially driving the rows output high one at a time via the states `S1_R0` to `S4_R3`. After selecting a row, it enters a corresponding check state (`S5_CHECK_R0` to `S8_CHECK_R3`) where it examines the `col` input lines to detect if any key in that row is pressed.

A `counter` is used to enforce a short `SCAN_DELAY` between row scans. If a column input is detected, the FSM moves to the `S9_CHECKING` state, where it waits for `DEBOUNCE` clock cycles to ensure the key press is stable. Once confirmed, the FSM transitions to `S10_PRESSED`, generating a one-cycle pulse `num_new` to signal a newly pressed key. Then, it enters the `S11_WAIT` state, using `HOLD_TIME` with the `counter` to wait for the key to be released before returning to S0_IDLE. 

The `rows` register is updated via `newRows` when `rowChange` is asserted, and the `increment` and `clear` signals control the `counter` for timing across the scan, debounce, and hold states.

The `keypad_scan` design combines row scanning, key detection, and debouncing into a single FSM, making it resource-efficient and better synchronized, but is less modular and with increased complexity. In contrast, my initial design of splitting the scanner/decoder and debouncing FSMs into two separates debouncing from key decoding, improving modularity and flexibility in debounce timing, but it uses more hardware and requires more attention regarding timing for accurate key detection.

![Figure 1: FSM of the keypad-scan module](images/lab3-fsm.jpg)

| state       | output                                                | nextstate                                                                                            |
|:-----------:|:-----------------------------------------------------:|:----------------------------------------------------------------------------------------------------:|
| S0_IDLE     | `clear` = 1                                           | S1_R0                                                                                                |
| S1_R0       | `newRows` = 4'b0001<br>`rowChange` = 1<br>`clear` = 1 | S5_CHECK_R0                                                                                          |
| S2_R1       | `newRows` = 4'b0010<br>`rowChange` = 1<br>`clear` = 1 | S6_CHECK_R1                                                                                          |
| S3_R2       | `newRows` = 4'b0100<br>`rowChange` = 1<br>`clear` = 1 | S7_CHECK_R2                                                                                          |
| S4_R3       | `newRows` = 4'b1000<br>`rowChange` = 1<br>`clear` = 1 | S8_CHECK_R3                                                                                          |
| S5_CHECK_R0 | `increment` = 1                                       | `|col`: S9_CHECKING<br>`counter >= SCAN_DELAY`: S2_R1<br>S5_CHECK_R0                                 |
| S6_CHECK_R1 | `increment` = 1                                       | `|col`: S9_CHECKING<br>`counter >= SCAN_DELAY`: S3_R2<br>S6_CHECK_R1                                 |
| S7_CHECK_R2 | `increment` = 1                                       | `|col`: S9_CHECKING<br>`counter >= SCAN_DELAY`: S4_R3<br>S7_CHECK_R2                                 |
| S8_CHECK_R3 | `increment` = 1                                       | `|col`: S9_CHECKING<br>`counter >= SCAN_DELAY`: S1_R0<br>S8_CHECK_R3                                 |
| S9_CHECKING | `increment` = 1                                       | `counter >= DEBOUNCE && |col`: S10_PRESSED<br>`counter >= DEBOUNCE && ~|col`: S0_IDLE<br>S9_CHECKING |
| S10_PRESSED | `num_new` = 1                                         | S11_WAIT                                                                                             |
| S11_WAIT    |  `increment` = 1                                      | `~|col && counter >= HOLD_TIME`: S0_IDLE<br>S11_WAIT                                                 |
: FSM State Transition Table {#transition-tbl}

Internal pull-up resistors were utilized to prevent floating values on the asynchronous column inputs of the 4x4 matrix keypad. These created an active-low standard in the HDL.

These physical features below were derived in the earlier Lab 2, but here is the calculations for them as well:

The PNP transistor was utilized to source more current for the dual seven-segment display. With only a 8 mA current being sourced from each pin, it was not enough to power each cathode. As a result, the PNP transistors, given a 5 mA current from the base, or the pins, collected from the 3.3V voltage source and pulled a current enough to power the seven-segment display. The 5 mA current at the base was regulated by a resistor of 560 $\,\Omega$. This was calculated via Ohm's Law, $V = IR$, where the voltage drop was calculated by $2.6 - 0$. The $2.6 V$ was found by negating the voltage drop from the 3.3 V emitter to the base, as given by $V_{BE(Sat)}$ from the datasheet. The $0 V$ was so due to the pin it connected to was grounded. As a result, $(2.6 - 0) / 0.05 = 520\,\Omega$, and the resistor used was a similar 510 $\,\Omega$. The datasheet mentioned is [linked here](https://hmc-e155.github.io/assets/doc/2N3906-D.pdf).

The resistors for each segment of the red dual seven-segment display were chosen based on the datasheet [linked here](https://docs.broadcom.com/doc/HDSP-521A-523A-Dual-Digit-General-Purpose-7-Segment-Display-DS). Around a forward current of 5mA, the forward voltage of each LED segment drops down to 1.8V. Due to the $V_{CE(Sat)} = 0.7$ at a current of 1 mA, there was a voltage drop from the emitter to the collector, resulting in the collector being at roughly 3 V. Knowing this, we can reconfigure Ohm's Law to figure out the appropriate resistor. $R = V/I = (3.0 - 1.8) / 0.002 = 600$, or roughly 620 $\,\Omega$.

## Technical Documentation

The source code for the project can be found in this [GitHub repository](https://github.com/mayu-tatsu/e155-lab3-2/).

### Block Diagram

![Figure 2: Block diagram of the Lab 3 HDL code](images/lab3-block.jpg)

Figure 3 depicts the block diagram of the design. The top-level module `lab3_mt` instantiates eight submodules within it. `clk_gen` houses the clock generation using the onboard high-speed oscillator through the HSOSC module and a counter to divide it down to both 10 kHz and 100 Hz. The `synchronizer` instantiates a simple two-stage flip-flop to synchronize the asynchronous column inputs into `sync_col`. `sync_col` is then passed into the `keypad` submodules, which include `keypad_scan`, `keypad_decoder`, and `keypad_storage`. The `keypad_scan` module drives each of the rows and detects any key presses, generating a one-cycle pulse `num_new` for each newly pressed key. The `keypad_decoder` module uses combinational logic to translate the active row and column into a 4-bit key value, while `keypad_storage` records the most recent and previous key presses using D-flip-flops. These stored values are then sent to the `sev_seg_sel` and `sev_seg` modules (written for Labs 1 and 2), which multiplex and convert the 4-bit values into 2 seven-segment displays, allowing both the current and previous key presses to be displayed.

### Schematic

![Figure 3: Schematic of the external hardware used for Lab 3](images/lab3-schem.jpg)

Figure 4 depicts the physical schematic of the design. The almost all I/O pins were utilized. Same as Lab 2, each cathode segment of the dual seven-segment display was connected to a pin, and the two common anodes of the display were connected from a source-generating PNP transistor, which were also connected to a pin each on the FPGA. Those pins were enabled and disabled by the `seg1en` and `seg2en` enable signals. The 4-bit `row` outputs and `async_col` inputs of the 4x4 matrix keypad were each assigned to a pin, with the `async_col` values connected to 6.8k$\,\Omega$ internal pullup resistors, specified in Lattice. 

## Results and Discussion

### Testbench Simulation

The design did met all intended design objectives, and behaves as expected under testbench testing.

![Figure 4: Waveforms made by clk_gen testbench](images/lab3-clk-gen-waves.png)

![Figure 5: Waveforms made by synchronizer testbench](images/lab3-synchronizer-waves.png)

![Figure 6: Waveforms made by keypad_scan testbench](images/lab3-keypad-scan-waves.png)

![Figure 7: Output from keypad_decoder testbench](images/lab3-keypad-decoder-results.png)

![Figure 8: Waveforms made by keypad_storage testbench](images/lab3-keypad-storage-waves.png)

![Figure 9: Waveforms made by sev_seg_sel testbench](images/lab3-sev-seg-sel-waves.png)

![Figure 10: Waveforms made by sev_seg testbench](images/lab3-sev-seg-waves.png)

## Conclusion

The design made in this lab was successful. After my initial failure, I completely redid my FSM, combining the two into one since I felt like that the interaction between the two FSMs was difficult to parse and debug. One of the reasons I had a difficult time getting this lab to work in the initial time allotted was bcause most of my time was spent trying to debug a segmentation-violation error that came up on Lattice during synthesis. In the end, I swtiched to Synplify Pro synthesizer under direction of TA Kavi, who was unable to solve the issue as well. Through this learning process, I learned how to design more robust FSMs and debug active-low/active-high systems. Overall, I was able to drive a dual seven-segment matrix given inputs from a 4x4 matrix keypad and display the most recent and the last key value pressed. 30 hours were spent on this lab, along with roughly 20 hours for the redo (so 50 total).

## AI Prototype Summary
::: {.grid}
::: {.g-col-5}
### Abriged Chat Log

> **First Prompt:** Target device: Lattice iCE40 UP5K FPGA. Overall Goal: Write SystemVerilog to scan a 4x4 matrix keypad and display the last two hex keys pressed on a dual 7 segment display. Current Goal: Write a synthesizable SystemVerilog module that produces a one‑shot registration signal for the keypad system. Behavior: When a key press is first detected, capture the current key code and assert a single‑cycle “new key” pulse. While any key remains pressed, do not accept additional keys. Only after keys are released should a subsequent press be recognized. This should handle debouncing of the keys. Implement as a small synchronous FSM with enumerated states and glitch‑free outputs. Keep names and interfaces reasonable; do not assume any hidden modules beyond what you define here.

The module uses a small synchronous finite state machine (FSM) to manage key detection, debouncing, and one-shot pulse generation. The FSM transitions between states to handle the debouncing of both key presses and releases. A `counter` is used to time the debounce periods, ensuring a stable signal before a key press is registered or the system is reset. The output `key_strobe` is a single-cycle pulse that is generated only once per stable key press. The `key_code` is also a registered output, making both outputs glitch-free and suitable for subsequent synchronous logic.

> **Second Prompt:** Target device: Lattice iCE40 UP5K FPGA. Write a synthesizable SystemVerilog module that cycles through keypad columns (active‑low, one at a time) and samples rows (active‑low) to detect a single key at a time. Behavior: Iterate columns at a suitable scan rate derived from the divided clock and sample rows.
When a key is detected, report a stable key code consistent with a standard 4x4 keypad layout and maintain it while the key remains pressed. Provide a boolean signal indicating whether any key is currently pressed. Use clean state encoding and synchronous logic; avoid combinational feedback and latches.

I will write a synthesizable SystemVerilog module that performs the keypad scanning logic you've described. This module will actively drive the columns and read the rows to detect a key press. It will provide a stable key code and a "key pressed" indicator signal.


> **Third Prompt:** Target device: Lattice iCE40 UP5K FPGA with internal oscillator as the root clock source. Write a top‑level SystemVerilog module that instantiates the scanner and one‑shot modules, shifts the last two keys (older ← most recent; most recent ← new), and drives a multiplexed two‑digit seven‑segment display. Requirements: Update the displayed digits only when a new key is registered. Ensure equal apparent brightness and no visible flicker. Keep all logic synthesizable and synchronous; use idiomatic SystemVerilog constructs. Provide any small clock‑enable or divider logic you need. You can also assume that a sevenSegment module exists that takes a 4 bit input and outputs the 7 segments.

1. `keypad_top.sv`: This is the top-level module. It handles the system clock, instantiates and connects the scanner and one-shot modules, implements a two-key shift register, and controls a multiplexed dual 7-segment display.
2. `keypad_scanner.sv`: This module, provided in your most recent context, is responsible for matrix scanning and converting the detected key press into a stable 4-bit code.
3. `keypad_register.sv`: This is a modified version of the one-shot module. It now takes a key code and a key_valid signal from the scanner and produces a single-cycle key_strobe pulse, effectively debouncing the scanner's output.
4. `sevenSegment.sv`: A simple combinational decoder module to convert a 4-bit hexadecimal value into a 7-segment display pattern.

The keypad_top module uses a dedicated counter to cycle between the two display digits at a rate of approximately 2 kHz, which is fast enough to eliminate visible flicker. The last_key and current_key registers are updated only on the rising edge of the key_strobe signal, ensuring the displayed values are stable and change only when a new, valid key is pressed.

> **Fourth Prompt:** the line if (|~row_in) begin in keypad_scanner throws a syntax error

The issue stems from using |~row_in, which can be ambiguous to some compilers. A more robust and clearer way to check for an active-low input is to use the reduction NOR operator ~| or to check if the input is not equal to all ones. I've updated the keypad_scanner.sv module to use the reduction NOR operator for better compatibility.

> **Fifth Prompt:** sevensegment.sv(62): duplicate module name sevenSegment

That's a very common error in hardware design. The "duplicate module name" error means that the synthesis tool is finding more than one definition for the sevenSegment module during compilation.

This typically happens when a single project directory contains multiple files with the same module definition, and they are all included or compiled together. The solution is to ensure each module is defined only once. To fix this and provide you with a clean, working set of files, I've regenerated all the required modules.

:::
::: {.g-col-7}
### Reflection

I used Gemini's 2.5-Flash model for this prototype. Its complete and fixed output for all prompts, synthesized in a Radiant project, are in this repo [linked here](https://github.com/mayu-tatsu/e155-lab23/tree/main/lab3_llm/source/impl_1). After all 3 prompts, it was unsynthesizable. It generated 4 files, `keypad_top`, `keypad_register`, `keypad_scanner`, and `sevenSegment`. Initially, there was a syntax error where the synthesizer couldn't accept the syntax for `|~`, which was fixed by switching to `~|`. Then, there was a persistent issue where the synthesizer recognized a duplicate module for sevenSegment, which was confusing as the module was both declared and instantiated only once. 

Regarding the output, I found the naming conventions interesting and the header comment as well. There wasn't any difficulties understanding the syntax, other than some of the flop conventions that the LLM produced. As an LLM with little context, however, it seems like it is unable to grasp how and why the final error popped up, and was unable to fix it. As a result, I would rate this module a 6/10. I think the concepts and the structure of the module work fine, but it isn't synthesizable at all and has issues when interacting with the rest of the project.

As a result of these LLM outputs, I haven't changed my stance on using LLMs for these projects. I could probably use it to help write common and/or redundant idioms. However, I am still uncertain of its ability to use external contexts and provide a synthesizable and working module, especially regarding redundant and duplicate content. While coding, it may be a good idea to consult the LLM to figure out reference idioms and removing small bugs and typos, but not good enough to completely generate any program.
:::
:::

## Initial Attempt

![Figure 11: Decoding FSM](images/lab3-keypad-fsm.jpg)

![Figure 12: Debouncing FSM](images/lab3-debouncer-fsm.jpg)