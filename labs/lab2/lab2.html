<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Mayu Tatsumi">
<meta name="dcterms.date" content="2025-09-11">
<meta name="description" content="Lab 2">

<title>Lab 2: Multiplexed 7-Segment Display – E155 Portfolio</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-c1fac2584b48ed01fb6e278e36375074.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">E155 Portfolio</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../labs.html"> 
<span class="menu-text">Labs</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../resources.html"> 
<span class="menu-text">Resources</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#design-and-testing-methodology" id="toc-design-and-testing-methodology" class="nav-link" data-scroll-target="#design-and-testing-methodology">Design and Testing Methodology</a></li>
  <li><a href="#technical-documentation" id="toc-technical-documentation" class="nav-link" data-scroll-target="#technical-documentation">Technical Documentation</a>
  <ul class="collapse">
  <li><a href="#block-diagram" id="toc-block-diagram" class="nav-link" data-scroll-target="#block-diagram">Block Diagram</a></li>
  <li><a href="#schematic" id="toc-schematic" class="nav-link" data-scroll-target="#schematic">Schematic</a></li>
  </ul></li>
  <li><a href="#results-and-discussion" id="toc-results-and-discussion" class="nav-link" data-scroll-target="#results-and-discussion">Results and Discussion</a>
  <ul class="collapse">
  <li><a href="#testbench-simulation" id="toc-testbench-simulation" class="nav-link" data-scroll-target="#testbench-simulation">Testbench Simulation</a></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  <li><a href="#ai-prototype-summary" id="toc-ai-prototype-summary" class="nav-link" data-scroll-target="#ai-prototype-summary">AI Prototype Summary</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Lab 2: Multiplexed 7-Segment Display</h1>
  <div class="quarto-categories">
    <div class="quarto-category">labreport</div>
  </div>
  </div>

<div>
  <div class="description">
    Lab 2
  </div>
</div>


<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Mayu Tatsumi </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">September 11, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>In this lab, the I/O pins on the FPGA board were efficiently utilized to drive a dual-seven segment display and five LEDs. This was achieved in combination with a time multiplexer and PNP transistors, considering the limited amount of usable pins. An HDL program was synthesized and mapped onto the FPGA memory, specifically built in a modular design to make reusability and testability tight and easy.</p>
<p>The goal of the lab was to have two 4-digit binary switches that each controlled a 7-segment display and its sum was presented as a binary 5-digit number through a row of 5 LEDs. The constraint was that there were only so many I/O pins, and so each of the segments of the dual seven-segment displays had to share a pin.</p>
<p>LINK: <a href="https://hmc-e155.github.io/lab/lab2/">E155 Lab 2 Instructions</a></p>
</section>
<section id="design-and-testing-methodology" class="level2">
<h2 class="anchored" data-anchor-id="design-and-testing-methodology">Design and Testing Methodology</h2>
<p>The time-multiplexed dual seven-segment display was controlled by two enable signals and 7 segment values. Due to the shared resources of the wires and pins, it was necessary to oscillate the enable signals and the segment values, which each connected to the cathodes. The oscillation made sure that only one display would be on at one time, with the correct value. The enable signals each connected to the common anode of a seven-segment display, and if one was high, the other was low to ensure only one would be on. While each cathode shared a pin with the same cathode segment of the other display, the enable signals made sure that, again, only one display would be on, and that the number displayed would belong to the right display and switch.</p>
<p>The PNP transistor was utilized to source more current. With only a 8 mA current being sourced from each pin, it was not enough to power each cathode. As a result, the PNP transistors, given a 5 mA current from the base, or the pins, collected from the 3.3V voltage source and pulled a current enough to power the seven-segment display. The 5 mA current at the base was regulated by a resistor of 560 <span class="math inline">\(\,\Omega\)</span>. This was calculated via Ohm’s Law, <span class="math inline">\(V = IR\)</span>, where the voltage drop was calculated by <span class="math inline">\(2.6 - 0\)</span>. The <span class="math inline">\(2.6 V\)</span> was found by negating the voltage drop from the 3.3 V emitter to the base, as given by <span class="math inline">\(V_{BE(Sat)}\)</span> from the datasheet. The <span class="math inline">\(0 V\)</span> was so due to the pin it connected to was grounded. As a result, <span class="math inline">\((2.6 - 0) / 0.05 = 520\,\Omega\)</span>, and the resistor used was a similar 510 <span class="math inline">\(\,\Omega\)</span>. The datasheet mentioned is <a href="https://hmc-e155.github.io/assets/doc/2N3906-D.pdf">linked here</a>.</p>
<p>The resistors for the green LEDs on the breadboard were calculated by <span class="math inline">\(V = IR\)</span> as well, but this time considering the forward voltage of the green LED, approximated as 2V at a lower current test condition. Considering the voltage drop and the target current of about 2 mA, <span class="math inline">\(V = IR\)</span> reduces to <span class="math inline">\(R = (3.3 - 2) / 0.02  = 0.65\)</span>, or roughly 620 <span class="math inline">\(\,\Omega\)</span>.</p>
<p>The resistors for the red dual seven-segment display were chosen based on the datasheet <a href="https://docs.broadcom.com/doc/HDSP-521A-523A-Dual-Digit-General-Purpose-7-Segment-Display-DS">linked here</a>. Around a forward current of 5mA, the forward voltage of each LED segment drops down to 1.8V. Due to the <span class="math inline">\(V_{CE(Sat)} = 0.7\)</span> at a current of 1 mA, there was a voltage drop from the emitter to the collector, resulting in the collector being at roughly 3 V. Knowing this, we can reconfigure Ohm’s Law to figure out the appropriate resistor. <span class="math inline">\(R = V/I = (3.0 - 1.8) / 0.002 = 600\)</span>, or roughly 620 <span class="math inline">\(\,\Omega\)</span>.</p>
</section>
<section id="technical-documentation" class="level2">
<h2 class="anchored" data-anchor-id="technical-documentation">Technical Documentation</h2>
<p>The source code for the project can be found in this <a href="https://github.com/mayu-tatsu/e155-lab2">GitHub repository</a>.</p>
<section id="block-diagram" class="level3">
<h3 class="anchored" data-anchor-id="block-diagram">Block Diagram</h3>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/lab2-block.jpg" class="img-fluid figure-img"></p>
<figcaption>Figure 1: Block diagram of the Lab 1 HDL code</figcaption>
</figure>
</div>
<p>Figure 1 depicts the block diagram of the design. The top-level module <code>lab2_mt</code> instantiates four submodules within it. <code>clk_gen</code> houses the <code>clk</code> generation using the onboard high-speed oscillator through the <code>HSOSC</code> module. <code>sev_seg_sel</code> uses a clock divider to divide that oscillation down into a much slower frequency of 100 Hz. It creates two opposite, toggling enable signals for each dual seven-segment display. It also chooses which of the input switches to output as <code>sw</code>, depending on the enables. <code>sev_seg</code> is a module written for Lab 1 that was repurposed for this lab. It takes in some 4-bit binary switch input to output a 7-bit binary LED segment output. Finally, the <code>led_adder</code> is the module that takes in the 4-bit binary switch values to output their sum as a 5-bit binary LED value.</p>
</section>
<section id="schematic" class="level3">
<h3 class="anchored" data-anchor-id="schematic">Schematic</h3>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/lab2-schem.jpg" class="img-fluid figure-img"></p>
<figcaption>Figure 2: Schematic of the external hardware used for Lab 2 design; doesn’t have the correct resistor values on it despite multiple updates and the right jpg being in the images folder.</figcaption>
</figure>
</div>
<p>Figure 2 depicts the physical schematic of the design. The I/O pins were maxed out, with every single one of them connected to something. Two 4-digit DIP switches were used as the input for the program, with one soldered onto the PCB and another wired into the breadbord. A green LED each connected to an I/O pin, wired to the breadboard, and connected with a 620 <span class="math inline">\(\,\Omega\)</span> current-limiting resistor. The reset was routed to a button on the board. Each cathode segment of the dual seven-segment display was connected to a pin, and the two common anodes of the display were connected from a source-generating PNP transistor, which were also connected to a pin each on the FPGA. Those pins were enabled and disabled by the <code>seg1en</code> and <code>seg2en</code> enable signals.</p>
</section>
</section>
<section id="results-and-discussion" class="level2">
<h2 class="anchored" data-anchor-id="results-and-discussion">Results and Discussion</h2>
<section id="testbench-simulation" class="level3">
<h3 class="anchored" data-anchor-id="testbench-simulation">Testbench Simulation</h3>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/lab2-mt-waves.png" class="img-fluid figure-img"></p>
<figcaption>Figure 3: Waveform output of top-level module <code>lab2_mt</code> testbench</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/clk-gen-waves.png" class="img-fluid figure-img"></p>
<figcaption>Figure 4: Waveform output of module <code>clk_gen</code> testbench</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/sev-seg-sel-waves.png" class="img-fluid figure-img"></p>
<figcaption>Figure 5: Waveform output of module <code>sev_seg_sel</code> testbench</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/sev-seg-waves.png" class="img-fluid figure-img"></p>
<figcaption>Figure 6: Waveform output of module <code>sev_seg</code> testbench</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/led-adder-waves.png" class="img-fluid figure-img"></p>
<figcaption>Figure 7: Waveform output of module <code>led_adder</code> testbench</figcaption>
</figure>
</div>
<p>The design met all intended design objectives. Figures 3 to 7 show screenshots of the QuestaSim simulation of the testbenches designed for each module. Figures 8 to 12 below show screenshots of the terminal output of the testbench modules, confirming successful simulation and no errors.</p>
<p>The <code>lab2_mt</code> top-level module’s testbench was the most robust out of all testbenches. By generating a clk within the module, it was possible to apply a stimulus, check via assert of the <code>seg</code> output, and delay some time and then check again while expecting a differing output. With each delay, opposing <code>seg1en</code> and <code>seg2en</code> signals were expected as well. <code>led</code> was expected to stay the same for either signal as long as the stimulus stayed the same.</p>
<p>The <code>clk_gen</code> testbench was a relatively simple design, where it was verified that the clk was off at one point and on the other within a reasonable time frame considering its 6 MHz frequency. The <code>sev_seg_sel</code> testbench was similar to the <code>lab2_mt</code> testbench with delays to check timings and make sure the enable signals are switching, along with the <code>seg</code> values depending on which signal was enabled. <code>sev_seg</code> testbench was repurposed from Lab 1, with only minor naming convention changes applied. The <code>led_adder</code> testbench was simple as well, checking that the adder had the correct logic, and there was no need to consider timing at all.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/lab2-mt-output.png" class="img-fluid figure-img"></p>
<figcaption>Figure 8: Terminal output of top-level module <code>lab2_mt</code> testbench</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/clk-gen-output.png" class="img-fluid figure-img"></p>
<figcaption>Figure 9: Terminal output of module <code>clk_gen</code> outptestbenchut</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/sev-seg-sel-output.png" class="img-fluid figure-img"></p>
<figcaption>Figure 10: Terminal output of module <code>sev_seg_sel</code> testbench</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/sev-seg-output.png" class="img-fluid figure-img"></p>
<figcaption>Figure 11: Terminal output of module <code>sev_seg</code> testbench</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/led-adder-output.png" class="img-fluid figure-img"></p>
<figcaption>Figure 12: Terminal output of module <code>led_adder</code> testbench</figcaption>
</figure>
</div>
</section>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>The design made in this lab successfully operated a time-multiplexed, dual seven-segment display. They were operated by two DIP switches, which provided two 4-digit binary inputs. The sum of both numbers displayed were shown as a 5-digit binary output through green LEDs. The lab exercised knowledge in FPGA I/O pins, PNP transistor calculations, and clock timings. Total hours worked: 16 hours (Rough breakdown: 2 planning, 3 writing code, 5 testbench, 3 wiring, 3 portfolio + AI).</p>
</section>
<section id="ai-prototype-summary" class="level2">
<h2 class="anchored" data-anchor-id="ai-prototype-summary">AI Prototype Summary</h2>
<div class="grid">
<section id="log-not-including-code" class="level3 g-col-5">
<h3 class="anchored" data-anchor-id="log-not-including-code">Log (not including code)</h3>
<blockquote class="blockquote">
<p><strong>First Prompt:</strong> Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits.</p>
</blockquote>
<p>You can time multiplex a single seven-segment decoder to drive two separate displays by rapidly switching between them. This approach uses a single decoder and associated circuitry to display different information on each display in an alternating fashion, relying on the persistence of human vision to create the illusion that both are lit simultaneously.</p>
<p>The SystemVerilog module <code>seven_seg_mux</code> implements a time multiplexer for two common anode seven-segment displays. It takes two 4-bit inputs (<code>in_0</code>, <code>in_1</code>), a clock signal (<code>clk</code>), and a reset signal (<code>rst_n</code>). It outputs the 7-bit decoded signal (<code>anode_out</code>) and a 2-bit anode select signal (<code>anode_sel</code>).</p>
<blockquote class="blockquote">
<p><strong>Second Prompt:</strong> Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.</p>
</blockquote>
<p>I can certainly help with that. Here is the SystemVerilog HDL to time multiplex a single seven-segment decoder. This module utilizes the <code>sev_seg</code> and <code>leds</code> modules you provided to drive two displays with different inputs. The time multiplexing is achieved by using a high-speed oscillator to rapidly switch between the two inputs.</p>
<p>This SystemVerilog file, <code>seven_seg_mux.sv</code>, contains a top-level module that demonstrates the time multiplexing. It instantiates the <code>sev_seg</code> module to handle the decoding and uses a clock signal from the <code>leds</code> module to rapidly switch between <code>s1</code> and <code>s2</code>. It then drives the <code>seg</code> outputs and the an (anode) outputs to select which display is active at any given time.</p>
</section>
<section id="reflection" class="level3 g-col-7">
<h3 class="anchored" data-anchor-id="reflection">Reflection</h3>
<p>I used Gemini’s 2.5-Flash model for this prototype. Its complete and fixed output for the first prompt is as <a href="https://github.com/mayu-tatsu/e155-lab2/tree/main/lab2_llm_1/source/impl_1">linked here</a>. It was synthesizable from the first prompt, where the two modules, <code>seven_seg_mux</code> and <code>seven_seg_decoder</code>, were provided and worked in sync with each other. The modules were not surprising at all, and closely replicated what we created for Lab 1. While I can’t be sure about the correctness of the combinational logic in <code>seven_seg_decoder</code> due to its lack of a linked datasheet or part number, this program did synthesize. The clock divider and selector logic in <code>seven_seg_mux</code> were very standard and easy to read. The instantiation was easier to read as a result of the labeled ports as well. I would rate this an 8/10 due to the lack of transparency about the combinational logic.</p>
<p>The second output can be found <a href="https://github.com/mayu-tatsu/e155-lab2/tree/main/lab2_llm_2/source/impl_1">here</a>. The modules <code>leds</code> and <code>sev_seg</code> were written by me for Lab 1, which was attached to the second prompt, and the module <code>seven_seg_mux</code> was generated by the LLM. There wasn’t anything totally new there either, other than a ternary operator that totally made sense but I hardly use (I know I should use it more). It was a little difficult to read becuase it had so many comments, but I think as a LLM and chatbot, it makes sense that there are a lot of redundant comments to explain its process. It was also able to mesh with my code that I provided pretty seamlessly, which was pretty cool (and scary). With synthesis being successful on the first try and decently clear code, I would rate this module a 9/10.</p>
<p>As a result of these LLM outputs, I think I could possibly use it to help write common and/or redundant idioms. However, I am still uncertain of its ability to read datasheets and figure out the connection between software and hardware, especially regarding pin numbers and naming conventions. While coding, it may be a good idea to consult the LLM to figure out typical idioms and removing small bugs and typos, but I doubt it has the ability to create its own block diagrams and architecture from the ground up, especially without any prior documentation provided.</p>
</section>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/mayu-tatsu\.github\.io\/e155-portfolio\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>