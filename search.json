[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Initial Reflection\n\n\nGoals for this Semester in MicroPs\n\n\n\n\n\nAug 26, 2025\n\n\nMayu Tatsumi\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Mayu Tatsumi is a junior studying Engineering at Harvey Mudd College. She is interested in working in the camera and lighting industries and would like to become involved as an electrical engineer. She has prior experience working as a Systems Control intern specifically working on embedded systems and writing firmware. Outside of engineering, she is interested in movie & TV production, Formula 1, and gaming.\nThis is a Quarto website. To learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "Initial Reflection",
    "section": "",
    "text": "I had a blast this summer working as a Systems Control intern at a company working on some embedded systems for their robot. I mostly worked off what my mentor taught me and what I could soak up from the datasheets and user manuals, so I’m excited to get more formal and grounded education in this field.\nFor this semester, I’m determined to keep myself focused and engaged in class. I’ll write everything on paper since we’re going chalkboard method and keep all my devices in my bag unless I need to. I’ve found out that (surprise!) I actually do learn more via paper and pen, so I’ll try my best to stay locked in and get the most out of this class. I definitely will also review what I’ve learned in E85 since it’s been a while.\nI also want to technically improve my soldering skills and generally working with my hands when it comes to electronics. I had to do a lot of manually soldering and crimping parts together over the summer as well, and I found I had some trouble with it so I want to take this chance as a moment to improve for the future. I’ll have to make some time and take advantage of Mudd’s resources to practice and make perfect."
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "Lab 3: Keypad Scanner",
    "section": "",
    "text": "Nothing to see here just yet."
  },
  {
    "objectID": "labs/lab5/lab5.html",
    "href": "labs/lab5/lab5.html",
    "title": "Lab 5: Interrupts",
    "section": "",
    "text": "Nothing to see here just yet."
  },
  {
    "objectID": "labs/lab6/lab6.html",
    "href": "labs/lab6/lab6.html",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "",
    "text": "Nothing to see here just yet."
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab, the E155 Development Board was assembled for use for the rest of the semester. Preliminary testing was done on both FPGA and MCU components of the board via simple given projects. The primary objective of this lab was to program the FPGA to take binary input from 4 switches and output patterns using 3 LEDs and a seven-segment display.\nOne of the LEDs was designed to blink at 2.4 Hz by dividing the onboard high-speed oscillator, used as a clock, from 24 MHz. The two other LEDs were each programmed by applying a XOR and AND gate using 2 inputs from the 4 switches, following a truth table given in the instructions. The seven-segment display was programmed to display distince hexadecimal values between 0 to F given a combination of 4 binary inputs through the same switches.\nLINK: E155 Lab 1 Instructions"
  },
  {
    "objectID": "labs/lab1/lab1.html#introduction",
    "href": "labs/lab1/lab1.html#introduction",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab, the E155 Development Board was assembled for use for the rest of the semester. Preliminary testing was done on both FPGA and MCU components of the board via simple given projects. The primary objective of this lab was to program the FPGA to take binary input from 4 switches and output patterns using 3 LEDs and a seven-segment display.\nOne of the LEDs was designed to blink at 2.4 Hz by dividing the onboard high-speed oscillator, used as a clock, from 24 MHz. The two other LEDs were each programmed by applying a XOR and AND gate using 2 inputs from the 4 switches, following a truth table given in the instructions. The seven-segment display was programmed to display distince hexadecimal values between 0 to F given a combination of 4 binary inputs through the same switches.\nLINK: E155 Lab 1 Instructions"
  },
  {
    "objectID": "labs/lab1/lab1.html#design-and-testing-methodology",
    "href": "labs/lab1/lab1.html#design-and-testing-methodology",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nFor the blinking LED, the onboard high-speed oscillator, named HSOSC as part of the iCE40 UltraPlus primitive library, was used to generate a 24 MHz oscillation acting as a clock signal. Utilizing a counterFor the blinking led, the onboard high-speed oscillator, named HSOSC as part of the iCE40 UltraPlus primitive library, was used to generate a 24 MHz oscillation acting as a clock signal. Aiming for a 2.4 Hz signal, the clock divider was devised to use a counter that, between values of 0-5,000,000, kept the LED off, and between 5,000,000-10,000,000 turned the LED on. This was designed by dividing the 24 MHz clock down to 2.4 Hz requires a counter that reaches 10,000,000, ensuring the LED blinks at the desired frequency with a single on-off cycle per period. Testing for the blinking LED was conducted by an oscilloscope, where one probe was connected to the GND on the FPGA and the other at the anode of the diode.\nThe other two LEDs were implemented by following the truth tables, as displayed below. These are adapted from the Lab 1 Instructions, as linked above.\n\n\n\ns[1]\ns[0]\nled[0]\n\n\n\n\n0\n0\n0\n\n\n0\n1\n1\n\n\n1\n0\n1\n\n\n1\n1\n0\n\n\n\n\n\n\ns[3]\ns[2]\nled[1]\n\n\n\n\n0\n0\n0\n\n\n0\n1\n0\n\n\n1\n0\n0\n\n\n1\n1\n1\n\n\n\nThese tables can effectively be reduced to led[0] being the result of an XOR gate of s[0] and s[1], and led[1] an AND gate of s[3] and s[2].\nThe seven-segment display was programmed by using combinational logic and case statements in the HDL. Considering the limited current draw of the LED segments, it was necessary to calculate and assign resistors to each segment. Following \\(V = IR\\) and consulting datasheets for the HDSP-511A display, it was determined that these displays would have a forward voltage of between 1.8 to 2.1 V, and current 5 to 20 mA. Following the supplied 3.3 V, the optimal resistance was calculated by: \\[\\begin{aligned}\nR &= \\frac{V}{I}\\\\\\\\\n&= \\frac{3.3 - 2}{5*10^{-3}} \\\\\\\\\n&= 260\\, \\Omega\n\\end{aligned}\\] Considering that the targeted current draw was on the lower end of 5mA, the resistor value was rounded down to 220\\(\\,\\Omega\\)."
  },
  {
    "objectID": "labs/lab1/lab1.html#technical-documentation",
    "href": "labs/lab1/lab1.html#technical-documentation",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for the project can be found in this GitHub repository.\n\nBlock Diagram\n\n\n\nFigure 1\n\n\nFigure 1 depicts the block diagram of the design. The top-level module lab1_mt instantiates two submodules within it, one for the LED logic, leds, and another for the seven segment logic, sev_seg. Within the leds module, the HSOSC module was utilized to create an int_osc clock that was fed into a clock divider (that used a counter).\n\n\nSchematic\n\n\n\nFigure 2\n\n\nFigure 2 depicts the physical schematic of the design. Internal pullup resistors of 100k\\(\\,\\Omega\\) were used to ensure that the active low switches and reset button were not floating. The LEDs were each connected to 1k\\(\\,\\Omega\\) resistors, and each cathode of the seven-segment display was connected to a 220\\(\\,\\Omega\\) grounded resistor."
  },
  {
    "objectID": "labs/lab1/lab1.html#results-and-discussion",
    "href": "labs/lab1/lab1.html#results-and-discussion",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\nVideo Demonstration\nThis video below demonstrates all possible configurations of the switches and consequently the values of the LED and seven-segment display.\n\n\n\nTestbench Simulation\n\n\n\nFigure 3\n\n\n\n\n\nFigure 4\n\n\n\n\n\nFigure 5\n\n\nThe design met all intended design objectives. Figure 3, 4, and 5 show screenshots of the QuestaSim simulation of the testbenches designed for each module. Figures 6, 7, and 8 below show screenshots of the terminal output of the testbench modules, confirming zero errors and successful simulation. One note— since the 2.4 Hz blinking LED is difficult to test for in the testbench, it was forced to 0 through the command force led[2] 0 before running the testbench.\n\n\n\nFigure 6\n\n\n\n\n\nFigure 7\n\n\n\n\n\nFigure 8\n\n\n\n\nOscilloscope Trace\n\n\n\nFigure 9\n\n\nFigure 9 shows a screenshot of an oscilloscope verifying the 2.42 Hz frequency of the LED."
  },
  {
    "objectID": "labs/lab1/lab1.html#conclusion",
    "href": "labs/lab1/lab1.html#conclusion",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Conclusion",
    "text": "Conclusion\nOverall, the design blinked an LED at 2.4 Hz using the onboard high-speed oscillator, changed the state of two other LEDs depending on the input of the four switches, following the logic of a given truth table. The seven segment display was wired and programmed with combinational logic to display a hexadecimal value given the binary input through the same four switches. Roughly 20 hours were spent working on this lab. I spent a couple of hours stuck on some bugs with a digitally controlled oscillator, which I ended up scrapping."
  },
  {
    "objectID": "labs/lab1/lab1.html#ai-prototype-summary",
    "href": "labs/lab1/lab1.html#ai-prototype-summary",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\n\n\nSummarized Log\n\nFirst Prompt: Write SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.\n\nThis SystemVerilog code provides a solution for blinking an LED at a specific frequency on a Lattice iCE40 UP5K FPGA. … The generated file, led_blinker.sv … instantiates the SB_HFOSC primitive to get the 48 MHz clock signal and then uses an always_ff block to implement a counter that toggles the led output every 12 million clock cycles, achieving the requested 2 Hz blink rate.\n\nSecond Prompt: ERROR: instantiating unknown module SB_HFOSC\n\n…This is a common issue because SB_HFOSC is a vendor-specific primitive for Lattice iCE40 FPGAs, not a standard SystemVerilog module.\nTo resolve this, you need to ensure your toolchain is correctly configured for the Lattice iCE40 family. This typically involves:\n\nUsing a synthesis tool like Yosys with the icepack or nextpnr backends.\nMaking sure the primitive library files for the iCE40 family are included in your project or synthesis script.\n\n\nThird Prompt: Try using HSOSC instead\n\nI have updated the led_blinker.sv file to use the HSOSC module instead of SB_HFOSC.\n\n\nReflection\nI used Gemini’s 2.5-Flash model for this prototype. Its complete and fixed output, as linked here, easily got to a synthesizable state after 3 prompts. The comments for this file were easy to read and explained a lot, if not too much. As a standalone prompt, the LLM was unable to tell what onboard specs and modules were available— it could only guess based on the massive data it’s been trained on that the most average chip would have a SB_HFOSC internal oscillator. Without the context that this FGPA contains a HSOSC module, it makes sense that it was unable to write instantly usable code. However, just by passing in the error and giving the model a possible alternative, it was able to easily modify the first piece of code into a file that synthesized.\nThere were no new idioms, at least, for me. It mostly used logic, parameter, and localparam, which I have been familiar with since E85. The instantiation of the resulting HSOSC module was a little less descriptive and seems to have been copied over from the SB_HFOSC instantiation idiom. This makes sense as the model seemed to simply switch out the module name, although it could become a cause of issue for other pairs of modules. The clock divider idiom was as usual. As a result, I would rate this code 8/10.\nIn the future, I would probably LLMs to generate SystemVerilog code if I knew what kind of hardware or idioms it would use, and specify that. As an extension of that, I would also need to know what kind of onboard modules and libraries the model could use to fulfill the prompt.\n\n\n\n\n\nFigure 10\n\n\nFigure 10 is the initial error message generated by Radiant’s Lattice LSE Synthesis."
  },
  {
    "objectID": "labs/lab7/lab7.html",
    "href": "labs/lab7/lab7.html",
    "title": "Lab 7: The Advanced Encryption Standard",
    "section": "",
    "text": "Nothing to see here just yet."
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "In this lab, the I/O pins on the FPGA board were efficiently utilized to drive a dual-seven segment display and five LEDs. This was achieved in combination with a time multiplexer and PNP transistors, considering the limited amount of usable pins. An HDL program was synthesized and mapped onto the FPGA memory, specifically built in a modular design to make reusability and testability tight and easy.\nThe goal of the lab was to have two 4-digit binary switches that each controlled a 7-segment display and its sum was presented as a binary 5-digit number through a row of 5 LEDs. The constraint was that there were only so many I/O pins, and so each of the segments of the dual seven-segment displays had to share a pin.\nLINK: E155 Lab 2 Instructions"
  },
  {
    "objectID": "labs/lab2/lab2.html#introduction",
    "href": "labs/lab2/lab2.html#introduction",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "In this lab, the I/O pins on the FPGA board were efficiently utilized to drive a dual-seven segment display and five LEDs. This was achieved in combination with a time multiplexer and PNP transistors, considering the limited amount of usable pins. An HDL program was synthesized and mapped onto the FPGA memory, specifically built in a modular design to make reusability and testability tight and easy.\nThe goal of the lab was to have two 4-digit binary switches that each controlled a 7-segment display and its sum was presented as a binary 5-digit number through a row of 5 LEDs. The constraint was that there were only so many I/O pins, and so each of the segments of the dual seven-segment displays had to share a pin.\nLINK: E155 Lab 2 Instructions"
  },
  {
    "objectID": "labs/lab2/lab2.html#design-and-testing-methodology",
    "href": "labs/lab2/lab2.html#design-and-testing-methodology",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nThe time-multiplexed dual seven-segment display was controlled by two enable signals and 7 segment values. Due to the shared resources of the wires and pins, it was necessary to oscillate the enable signals and the segment values, which each connected to the cathodes. The oscillation made sure that only one display would be on at one time, with the correct value. The enable signals each connected to the common anode of a seven-segment display, and if one was high, the other was low to ensure only one would be on. While each cathode shared a pin with the same cathode segment of the other display, the enable signals made sure that, again, only one display would be on, and that the number displayed would belong to the right display and switch.\nThe PNP transistor was utilized to source more current. With only a 8 mA current being sourced from each pin, it was not enough to power each cathode. As a result, the PNP transistors, given a 5 mA current from the base, or the pins, collected from the 3.3V voltage source and pulled a current enough to power the seven-segment display. The 5 mA current at the base was regulated by a resistor of 560 \\(\\,\\Omega\\). This was calculated via Ohm’s Law, \\(V = IR\\), where the voltage drop was calculated by \\(2.6 - 0\\). The \\(2.6 V\\) was found by negating the voltage drop from the 3.3 V emitter to the base, as given by \\(V_{BE(Sat)}\\) from the datasheet. The \\(0 V\\) was so due to the pin it connected to was grounded. As a result, \\((2.6 - 0) / 0.05 = 520\\,\\Omega\\), and the resistor used was a similar 510 \\(\\,\\Omega\\). The datasheet mentioned is linked here.\nThe resistors for the green LEDs on the breadboard were calculated by \\(V = IR\\) as well, but this time considering the forward voltage of the green LED, approximated as 2V at a lower current test condition. Considering the voltage drop and the target current of about 2 mA, \\(V = IR\\) reduces to \\(R = (3.3 - 2) / 0.02  = 0.65\\), or roughly 620 \\(\\,\\Omega\\).\nThe resistors for the red dual seven-segment display were chosen based on the datasheet linked here. Around a forward current of 5mA, the forward voltage of each LED segment drops down to 1.8V. Due to the \\(V_{CE(Sat)} = 0.7\\) at a current of 1 mA, there was a voltage drop from the emitter to the collector, resulting in the collector being at roughly 3 V. Knowing this, we can reconfigure Ohm’s Law to figure out the appropriate resistor. \\(R = V/I = (3.0 - 1.8) / 0.002 = 600\\), or roughly 620 \\(\\,\\Omega\\)."
  },
  {
    "objectID": "labs/lab2/lab2.html#technical-documentation",
    "href": "labs/lab2/lab2.html#technical-documentation",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for the project can be found in this GitHub repository.\n\nBlock Diagram\n\n\n\nFigure 1: Block diagram of the Lab 1 HDL code\n\n\nFigure 1 depicts the block diagram of the design. The top-level module lab2_mt instantiates four submodules within it. clk_gen houses the clk generation using the onboard high-speed oscillator through the HSOSC module. sev_seg_sel uses a clock divider to divide that oscillation down into a much slower frequency of 100 Hz. It creates two opposite, toggling enable signals for each dual seven-segment display. It also chooses which of the input switches to output as sw, depending on the enables. sev_seg is a module written for Lab 1 that was repurposed for this lab. It takes in some 4-bit binary switch input to output a 7-bit binary LED segment output. Finally, the led_adder is the module that takes in the 4-bit binary switch values to output their sum as a 5-bit binary LED value.\n\n\nSchematic\n\n\n\nFigure 2: Schematic of the external hardware used for Lab 2 design; doesn’t have the correct resistor values on it despite multiple updates and the right jpg being in the images folder.\n\n\nFigure 2 depicts the physical schematic of the design. The I/O pins were maxed out, with every single one of them connected to something. Two 4-digit DIP switches were used as the input for the program, with one soldered onto the PCB and another wired into the breadbord. A green LED each connected to an I/O pin, wired to the breadboard, and connected with a 620 \\(\\,\\Omega\\) current-limiting resistor. The reset was routed to a button on the board. Each cathode segment of the dual seven-segment display was connected to a pin, and the two common anodes of the display were connected from a source-generating PNP transistor, which were also connected to a pin each on the FPGA. Those pins were enabled and disabled by the seg1en and seg2en enable signals."
  },
  {
    "objectID": "labs/lab2/lab2.html#results-and-discussion",
    "href": "labs/lab2/lab2.html#results-and-discussion",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\nTestbench Simulation\n\n\n\nFigure 3: Waveform output of top-level module lab2_mt testbench\n\n\n\n\n\nFigure 4: Waveform output of module clk_gen testbench\n\n\n\n\n\nFigure 5: Waveform output of module sev_seg_sel testbench\n\n\n\n\n\nFigure 6: Waveform output of module sev_seg testbench\n\n\n\n\n\nFigure 7: Waveform output of module led_adder testbench\n\n\nThe design met all intended design objectives. Figures 3 to 7 show screenshots of the QuestaSim simulation of the testbenches designed for each module. Figures 8 to 12 below show screenshots of the terminal output of the testbench modules, confirming successful simulation and no errors.\nThe lab2_mt top-level module’s testbench was the most robust out of all testbenches. By generating a clk within the module, it was possible to apply a stimulus, check via assert of the seg output, and delay some time and then check again while expecting a differing output. With each delay, opposing seg1en and seg2en signals were expected as well. led was expected to stay the same for either signal as long as the stimulus stayed the same.\nThe clk_gen testbench was a relatively simple design, where it was verified that the clk was off at one point and on the other within a reasonable time frame considering its 6 MHz frequency. The sev_seg_sel testbench was similar to the lab2_mt testbench with delays to check timings and make sure the enable signals are switching, along with the seg values depending on which signal was enabled. sev_seg testbench was repurposed from Lab 1, with only minor naming convention changes applied. The led_adder testbench was simple as well, checking that the adder had the correct logic, and there was no need to consider timing at all.\n\n\n\nFigure 8: Terminal output of top-level module lab2_mt testbench\n\n\n\n\n\nFigure 9: Terminal output of module clk_gen outptestbenchut\n\n\n\n\n\nFigure 10: Terminal output of module sev_seg_sel testbench\n\n\n\n\n\nFigure 11: Terminal output of module sev_seg testbench\n\n\n\n\n\nFigure 12: Terminal output of module led_adder testbench"
  },
  {
    "objectID": "labs/lab2/lab2.html#conclusion",
    "href": "labs/lab2/lab2.html#conclusion",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Conclusion",
    "text": "Conclusion\nThe design made in this lab successfully operated a time-multiplexed, dual seven-segment display. They were operated by two DIP switches, which provided two 4-digit binary inputs. The sum of both numbers displayed were shown as a 5-digit binary output through green LEDs. The lab exercised knowledge in FPGA I/O pins, PNP transistor calculations, and clock timings. Total hours worked: 16 hours (Rough breakdown: 2 planning, 3 writing code, 5 testbench, 3 wiring, 3 portfolio + AI)."
  },
  {
    "objectID": "labs/lab2/lab2.html#ai-prototype-summary",
    "href": "labs/lab2/lab2.html#ai-prototype-summary",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\n\n\nLog (not including code)\n\nFirst Prompt: Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits.\n\nYou can time multiplex a single seven-segment decoder to drive two separate displays by rapidly switching between them. This approach uses a single decoder and associated circuitry to display different information on each display in an alternating fashion, relying on the persistence of human vision to create the illusion that both are lit simultaneously.\nThe SystemVerilog module seven_seg_mux implements a time multiplexer for two common anode seven-segment displays. It takes two 4-bit inputs (in_0, in_1), a clock signal (clk), and a reset signal (rst_n). It outputs the 7-bit decoded signal (anode_out) and a 2-bit anode select signal (anode_sel).\n\nSecond Prompt: Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.\n\nI can certainly help with that. Here is the SystemVerilog HDL to time multiplex a single seven-segment decoder. This module utilizes the sev_seg and leds modules you provided to drive two displays with different inputs. The time multiplexing is achieved by using a high-speed oscillator to rapidly switch between the two inputs.\nThis SystemVerilog file, seven_seg_mux.sv, contains a top-level module that demonstrates the time multiplexing. It instantiates the sev_seg module to handle the decoding and uses a clock signal from the leds module to rapidly switch between s1 and s2. It then drives the seg outputs and the an (anode) outputs to select which display is active at any given time.\n\n\nReflection\nI used Gemini’s 2.5-Flash model for this prototype. Its complete and fixed output for the first prompt is as linked here. It was synthesizable from the first prompt, where the two modules, seven_seg_mux and seven_seg_decoder, were provided and worked in sync with each other. The modules were not surprising at all, and closely replicated what we created for Lab 1. While I can’t be sure about the correctness of the combinational logic in seven_seg_decoder due to its lack of a linked datasheet or part number, this program did synthesize. The clock divider and selector logic in seven_seg_mux were very standard and easy to read. The instantiation was easier to read as a result of the labeled ports as well. I would rate this an 8/10 due to the lack of transparency about the combinational logic.\nThe second output can be found here. The modules leds and sev_seg were written by me for Lab 1, which was attached to the second prompt, and the module seven_seg_mux was generated by the LLM. There wasn’t anything totally new there either, other than a ternary operator that totally made sense but I hardly use (I know I should use it more). It was a little difficult to read becuase it had so many comments, but I think as a LLM and chatbot, it makes sense that there are a lot of redundant comments to explain its process. It was also able to mesh with my code that I provided pretty seamlessly, which was pretty cool (and scary). With synthesis being successful on the first try and decently clear code, I would rate this module a 9/10.\nAs a result of these LLM outputs, I think I could possibly use it to help write common and/or redundant idioms. However, I am still uncertain of its ability to read datasheets and figure out the connection between software and hardware, especially regarding pin numbers and naming conventions. While coding, it may be a good idea to consult the LLM to figure out typical idioms and removing small bugs and typos, but I doubt it has the ability to create its own block diagrams and architecture from the ground up, especially without any prior documentation provided."
  },
  {
    "objectID": "labs/lab4/lab4.html",
    "href": "labs/lab4/lab4.html",
    "title": "Lab 4: Digital Audio",
    "section": "",
    "text": "Nothing to see here just yet."
  },
  {
    "objectID": "labs.html#lab-2-multiplexed-7-segment-display",
    "href": "labs.html#lab-2-multiplexed-7-segment-display",
    "title": "E155 Lab List",
    "section": "Lab 2: Multiplexed 7-Segment Display",
    "text": "Lab 2: Multiplexed 7-Segment Display"
  },
  {
    "objectID": "labs.html#lab-3-keypad-scanner",
    "href": "labs.html#lab-3-keypad-scanner",
    "title": "E155 Lab List",
    "section": "Lab 3: Keypad Scanner",
    "text": "Lab 3: Keypad Scanner"
  },
  {
    "objectID": "labs.html#lab-4-digital-audio",
    "href": "labs.html#lab-4-digital-audio",
    "title": "E155 Lab List",
    "section": "Lab 4: Digital Audio",
    "text": "Lab 4: Digital Audio"
  },
  {
    "objectID": "labs.html#lab-5-interrupts",
    "href": "labs.html#lab-5-interrupts",
    "title": "E155 Lab List",
    "section": "Lab 5: Interrupts",
    "text": "Lab 5: Interrupts"
  },
  {
    "objectID": "labs.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "href": "labs.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "title": "E155 Lab List",
    "section": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "text": "Lab 6: The Internet of Things and Serial Peripheral Interface"
  },
  {
    "objectID": "labs.html#lab-7-the-advanced-encryption-standard",
    "href": "labs.html#lab-7-the-advanced-encryption-standard",
    "title": "E155 Lab List",
    "section": "Lab 7: The Advanced Encryption Standard",
    "text": "Lab 7: The Advanced Encryption Standard"
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "E155 Resources",
    "section": "",
    "text": "Link to E155 Course Webpage"
  }
]