[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Initial Reflection\n\n\nGoals for this Semester in MicroPs\n\n\n\n\n\nAug 26, 2025\n\n\nMayu Tatsumi\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Mayu Tatsumi is a junior studying Engineering at Harvey Mudd College. She is interested in working in the camera and lighting industries and would like to become involved as an electrical engineer. She has prior experience working as a Systems Control intern specifically working on embedded systems and writing firmware. Outside of engineering, she is interested in movie & TV production, Formula 1, and gaming.\nThis is a Quarto website. To learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "Initial Reflection",
    "section": "",
    "text": "I had a blast this summer working as a Systems Control intern at a company working on some embedded systems for their robot. I mostly worked off what my mentor taught me and what I could soak up from the datasheets and user manuals, so I’m excited to get more formal and grounded education in this field.\nFor this semester, I’m determined to keep myself focused and engaged in class. I’ll write everything on paper since we’re going chalkboard method and keep all my devices in my bag unless I need to. I’ve found out that (surprise!) I actually do learn more via paper and pen, so I’ll try my best to stay locked in and get the most out of this class. I definitely will also review what I’ve learned in E85 since it’s been a while.\nI also want to technically improve my soldering skills and generally working with my hands when it comes to electronics. I had to do a lot of manually soldering and crimping parts together over the summer as well, and I found I had some trouble with it so I want to take this chance as a moment to improve for the future. I’ll have to make some time and take advantage of Mudd’s resources to practice and make perfect."
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "Lab 3: Keypad Scanner",
    "section": "",
    "text": "In this lab, the I/O pins on the FPGA board were interfaced with a 4x4 matrix keypad and a dual seven-segment display to display asynchronous user inputs in a synchronized fashion. A synchronizer was implemented for this purpose, along with a switch debouncer to prevent switch bounce.\nThe goal of the lab was to program the FPGA so that the most recent input on the matrix keypad would display on the right of the dual display, and any subsequent inputs would update the display so that the older inputs would shift left and so on. The design of this code and FSMs utilized needed to be robust to be able to deal with various user inputs and expectations.\nLINK: E155 Lab 3 Instructions"
  },
  {
    "objectID": "labs/lab3/lab3.html#introduction",
    "href": "labs/lab3/lab3.html#introduction",
    "title": "Lab 3: Keypad Scanner",
    "section": "",
    "text": "In this lab, the I/O pins on the FPGA board were interfaced with a 4x4 matrix keypad and a dual seven-segment display to display asynchronous user inputs in a synchronized fashion. A synchronizer was implemented for this purpose, along with a switch debouncer to prevent switch bounce.\nThe goal of the lab was to program the FPGA so that the most recent input on the matrix keypad would display on the right of the dual display, and any subsequent inputs would update the display so that the older inputs would shift left and so on. The design of this code and FSMs utilized needed to be robust to be able to deal with various user inputs and expectations.\nLINK: E155 Lab 3 Instructions"
  },
  {
    "objectID": "labs/lab3/lab3.html#design-and-testing-methodology",
    "href": "labs/lab3/lab3.html#design-and-testing-methodology",
    "title": "Lab 3: Keypad Scanner",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nThe main FSM (in keypad_scan module) scans the 4x4 matrix keypad and also includes debouncing logic. It cycles through the rows by sequentially driving the rows output high one at a time via the states S1_R0 to S4_R3. After selecting a row, it enters a corresponding check state (S5_CHECK_R0 to S8_CHECK_R3) where it examines the col input lines to detect if any key in that row is pressed.\nA counter is used to enforce a short SCAN_DELAY between row scans. If a column input is detected, the FSM moves to the S9_CHECKING state, where it waits for DEBOUNCE clock cycles to ensure the key press is stable. Once confirmed, the FSM transitions to S10_PRESSED, generating a one-cycle pulse num_new to signal a newly pressed key. Then, it enters the S11_WAIT state, using HOLD_TIME with the counter to wait for the key to be released before returning to S0_IDLE.\nThe rows register is updated via newRows when rowChange is asserted, and the increment and clear signals control the counter for timing across the scan, debounce, and hold states.\nThe keypad_scan design combines row scanning, key detection, and debouncing into a single FSM, making it resource-efficient and better synchronized, but is less modular and with increased complexity. In contrast, my initial design of splitting the scanner/decoder and debouncing FSMs into two separates debouncing from key decoding, improving modularity and flexibility in debounce timing, but it uses more hardware and requires more attention regarding timing for accurate key detection.\n\n\n\nFigure 1: FSM of the keypad-scan module\n\n\n\nFSM State Transition Table {#transition-tbl}\n\n\n\n\n\n\n\nstate\noutput\nnextstate\n\n\n\n\nS0_IDLE\nclear = 1\nS1_R0\n\n\nS1_R0\nnewRows = 4’b0001rowChange = 1clear = 1\nS5_CHECK_R0\n\n\nS2_R1\nnewRows = 4’b0010rowChange = 1clear = 1\nS6_CHECK_R1\n\n\nS3_R2\nnewRows = 4’b0100rowChange = 1clear = 1\nS7_CHECK_R2\n\n\nS4_R3\nnewRows = 4’b1000rowChange = 1clear = 1\nS8_CHECK_R3\n\n\nS5_CHECK_R0\nincrement = 1\n|col: S9_CHECKINGcounter &gt;= SCAN_DELAY: S2_R1S5_CHECK_R0\n\n\nS6_CHECK_R1\nincrement = 1\n|col: S9_CHECKINGcounter &gt;= SCAN_DELAY: S3_R2S6_CHECK_R1\n\n\nS7_CHECK_R2\nincrement = 1\n|col: S9_CHECKINGcounter &gt;= SCAN_DELAY: S4_R3S7_CHECK_R2\n\n\nS8_CHECK_R3\nincrement = 1\n|col: S9_CHECKINGcounter &gt;= SCAN_DELAY: S1_R0S8_CHECK_R3\n\n\nS9_CHECKING\nincrement = 1\ncounter &gt;= DEBOUNCE && |col: S10_PRESSEDcounter &gt;= DEBOUNCE && ~|col: S0_IDLES9_CHECKING\n\n\nS10_PRESSED\nnum_new = 1\nS11_WAIT\n\n\nS11_WAIT\nincrement = 1\n~|col && counter &gt;= HOLD_TIME: S0_IDLES11_WAIT\n\n\n\nInternal pull-up resistors were utilized to prevent floating values on the asynchronous column inputs of the 4x4 matrix keypad. These created an active-low standard in the HDL.\nThese physical features below were derived in the earlier Lab 2, but here is the calculations for them as well:\nThe PNP transistor was utilized to source more current for the dual seven-segment display. With only a 8 mA current being sourced from each pin, it was not enough to power each cathode. As a result, the PNP transistors, given a 5 mA current from the base, or the pins, collected from the 3.3V voltage source and pulled a current enough to power the seven-segment display. The 5 mA current at the base was regulated by a resistor of 560 \\(\\,\\Omega\\). This was calculated via Ohm’s Law, \\(V = IR\\), where the voltage drop was calculated by \\(2.6 - 0\\). The \\(2.6 V\\) was found by negating the voltage drop from the 3.3 V emitter to the base, as given by \\(V_{BE(Sat)}\\) from the datasheet. The \\(0 V\\) was so due to the pin it connected to was grounded. As a result, \\((2.6 - 0) / 0.05 = 520\\,\\Omega\\), and the resistor used was a similar 510 \\(\\,\\Omega\\). The datasheet mentioned is linked here.\nThe resistors for each segment of the red dual seven-segment display were chosen based on the datasheet linked here. Around a forward current of 5mA, the forward voltage of each LED segment drops down to 1.8V. Due to the \\(V_{CE(Sat)} = 0.7\\) at a current of 1 mA, there was a voltage drop from the emitter to the collector, resulting in the collector being at roughly 3 V. Knowing this, we can reconfigure Ohm’s Law to figure out the appropriate resistor. \\(R = V/I = (3.0 - 1.8) / 0.002 = 600\\), or roughly 620 \\(\\,\\Omega\\)."
  },
  {
    "objectID": "labs/lab3/lab3.html#technical-documentation",
    "href": "labs/lab3/lab3.html#technical-documentation",
    "title": "Lab 3: Keypad Scanner",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for the project can be found in this GitHub repository.\n\nBlock Diagram\n\n\n\nFigure 2: Block diagram of the Lab 3 HDL code\n\n\nFigure 3 depicts the block diagram of the design. The top-level module lab3_mt instantiates eight submodules within it. clk_gen houses the clock generation using the onboard high-speed oscillator through the HSOSC module and a counter to divide it down to both 10 kHz and 100 Hz. The synchronizer instantiates a simple two-stage flip-flop to synchronize the asynchronous column inputs into sync_col. sync_col is then passed into the keypad submodules, which include keypad_scan, keypad_decoder, and keypad_storage. The keypad_scan module drives each of the rows and detects any key presses, generating a one-cycle pulse num_new for each newly pressed key. The keypad_decoder module uses combinational logic to translate the active row and column into a 4-bit key value, while keypad_storage records the most recent and previous key presses using D-flip-flops. These stored values are then sent to the sev_seg_sel and sev_seg modules (written for Labs 1 and 2), which multiplex and convert the 4-bit values into 2 seven-segment displays, allowing both the current and previous key presses to be displayed.\n\n\nSchematic\n\n\n\nFigure 3: Schematic of the external hardware used for Lab 3\n\n\nFigure 4 depicts the physical schematic of the design. The almost all I/O pins were utilized. Same as Lab 2, each cathode segment of the dual seven-segment display was connected to a pin, and the two common anodes of the display were connected from a source-generating PNP transistor, which were also connected to a pin each on the FPGA. Those pins were enabled and disabled by the seg1en and seg2en enable signals. The 4-bit row outputs and async_col inputs of the 4x4 matrix keypad were each assigned to a pin, with the async_col values connected to 6.8k\\(\\,\\Omega\\) internal pullup resistors, specified in Lattice."
  },
  {
    "objectID": "labs/lab3/lab3.html#results-and-discussion",
    "href": "labs/lab3/lab3.html#results-and-discussion",
    "title": "Lab 3: Keypad Scanner",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\nTestbench Simulation\nThe design did met all intended design objectives, and behaves as expected under testbench testing.\n\n\n\nFigure 4: Waveforms made by clk_gen testbench\n\n\n\n\n\nFigure 5: Waveforms made by synchronizer testbench\n\n\n\n\n\nFigure 6: Waveforms made by keypad_scan testbench\n\n\n\n\n\nFigure 7: Output from keypad_decoder testbench\n\n\n\n\n\nFigure 8: Waveforms made by keypad_storage testbench\n\n\n\n\n\nFigure 9: Waveforms made by sev_seg_sel testbench\n\n\n\n\n\nFigure 10: Waveforms made by sev_seg testbench"
  },
  {
    "objectID": "labs/lab3/lab3.html#conclusion",
    "href": "labs/lab3/lab3.html#conclusion",
    "title": "Lab 3: Keypad Scanner",
    "section": "Conclusion",
    "text": "Conclusion\nThe design made in this lab was successful. After my initial failure, I completely redid my FSM, combining the two into one since I felt like that the interaction between the two FSMs was difficult to parse and debug. One of the reasons I had a difficult time getting this lab to work in the initial time allotted was bcause most of my time was spent trying to debug a segmentation-violation error that came up on Lattice during synthesis. In the end, I swtiched to Synplify Pro synthesizer under direction of TA Kavi, who was unable to solve the issue as well. Through this learning process, I learned how to design more robust FSMs and debug active-low/active-high systems. Overall, I was able to drive a dual seven-segment matrix given inputs from a 4x4 matrix keypad and display the most recent and the last key value pressed. 30 hours were spent on this lab, along with roughly 20 hours for the redo (so 50 total)."
  },
  {
    "objectID": "labs/lab3/lab3.html#ai-prototype-summary",
    "href": "labs/lab3/lab3.html#ai-prototype-summary",
    "title": "Lab 3: Keypad Scanner",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\n\n\nAbriged Chat Log\n\nFirst Prompt: Target device: Lattice iCE40 UP5K FPGA. Overall Goal: Write SystemVerilog to scan a 4x4 matrix keypad and display the last two hex keys pressed on a dual 7 segment display. Current Goal: Write a synthesizable SystemVerilog module that produces a one‑shot registration signal for the keypad system. Behavior: When a key press is first detected, capture the current key code and assert a single‑cycle “new key” pulse. While any key remains pressed, do not accept additional keys. Only after keys are released should a subsequent press be recognized. This should handle debouncing of the keys. Implement as a small synchronous FSM with enumerated states and glitch‑free outputs. Keep names and interfaces reasonable; do not assume any hidden modules beyond what you define here.\n\nThe module uses a small synchronous finite state machine (FSM) to manage key detection, debouncing, and one-shot pulse generation. The FSM transitions between states to handle the debouncing of both key presses and releases. A counter is used to time the debounce periods, ensuring a stable signal before a key press is registered or the system is reset. The output key_strobe is a single-cycle pulse that is generated only once per stable key press. The key_code is also a registered output, making both outputs glitch-free and suitable for subsequent synchronous logic.\n\nSecond Prompt: Target device: Lattice iCE40 UP5K FPGA. Write a synthesizable SystemVerilog module that cycles through keypad columns (active‑low, one at a time) and samples rows (active‑low) to detect a single key at a time. Behavior: Iterate columns at a suitable scan rate derived from the divided clock and sample rows. When a key is detected, report a stable key code consistent with a standard 4x4 keypad layout and maintain it while the key remains pressed. Provide a boolean signal indicating whether any key is currently pressed. Use clean state encoding and synchronous logic; avoid combinational feedback and latches.\n\nI will write a synthesizable SystemVerilog module that performs the keypad scanning logic you’ve described. This module will actively drive the columns and read the rows to detect a key press. It will provide a stable key code and a “key pressed” indicator signal.\n\nThird Prompt: Target device: Lattice iCE40 UP5K FPGA with internal oscillator as the root clock source. Write a top‑level SystemVerilog module that instantiates the scanner and one‑shot modules, shifts the last two keys (older ← most recent; most recent ← new), and drives a multiplexed two‑digit seven‑segment display. Requirements: Update the displayed digits only when a new key is registered. Ensure equal apparent brightness and no visible flicker. Keep all logic synthesizable and synchronous; use idiomatic SystemVerilog constructs. Provide any small clock‑enable or divider logic you need. You can also assume that a sevenSegment module exists that takes a 4 bit input and outputs the 7 segments.\n\n\nkeypad_top.sv: This is the top-level module. It handles the system clock, instantiates and connects the scanner and one-shot modules, implements a two-key shift register, and controls a multiplexed dual 7-segment display.\nkeypad_scanner.sv: This module, provided in your most recent context, is responsible for matrix scanning and converting the detected key press into a stable 4-bit code.\nkeypad_register.sv: This is a modified version of the one-shot module. It now takes a key code and a key_valid signal from the scanner and produces a single-cycle key_strobe pulse, effectively debouncing the scanner’s output.\nsevenSegment.sv: A simple combinational decoder module to convert a 4-bit hexadecimal value into a 7-segment display pattern.\n\nThe keypad_top module uses a dedicated counter to cycle between the two display digits at a rate of approximately 2 kHz, which is fast enough to eliminate visible flicker. The last_key and current_key registers are updated only on the rising edge of the key_strobe signal, ensuring the displayed values are stable and change only when a new, valid key is pressed.\n\nFourth Prompt: the line if (|~row_in) begin in keypad_scanner throws a syntax error\n\nThe issue stems from using |~row_in, which can be ambiguous to some compilers. A more robust and clearer way to check for an active-low input is to use the reduction NOR operator ~| or to check if the input is not equal to all ones. I’ve updated the keypad_scanner.sv module to use the reduction NOR operator for better compatibility.\n\nFifth Prompt: sevensegment.sv(62): duplicate module name sevenSegment\n\nThat’s a very common error in hardware design. The “duplicate module name” error means that the synthesis tool is finding more than one definition for the sevenSegment module during compilation.\nThis typically happens when a single project directory contains multiple files with the same module definition, and they are all included or compiled together. The solution is to ensure each module is defined only once. To fix this and provide you with a clean, working set of files, I’ve regenerated all the required modules.\n\n\nReflection\nI used Gemini’s 2.5-Flash model for this prototype. Its complete and fixed output for all prompts, synthesized in a Radiant project, are in this repo linked here. After all 3 prompts, it was unsynthesizable. It generated 4 files, keypad_top, keypad_register, keypad_scanner, and sevenSegment. Initially, there was a syntax error where the synthesizer couldn’t accept the syntax for |~, which was fixed by switching to ~|. Then, there was a persistent issue where the synthesizer recognized a duplicate module for sevenSegment, which was confusing as the module was both declared and instantiated only once.\nRegarding the output, I found the naming conventions interesting and the header comment as well. There wasn’t any difficulties understanding the syntax, other than some of the flop conventions that the LLM produced. As an LLM with little context, however, it seems like it is unable to grasp how and why the final error popped up, and was unable to fix it. As a result, I would rate this module a 6/10. I think the concepts and the structure of the module work fine, but it isn’t synthesizable at all and has issues when interacting with the rest of the project.\nAs a result of these LLM outputs, I haven’t changed my stance on using LLMs for these projects. I could probably use it to help write common and/or redundant idioms. However, I am still uncertain of its ability to use external contexts and provide a synthesizable and working module, especially regarding redundant and duplicate content. While coding, it may be a good idea to consult the LLM to figure out reference idioms and removing small bugs and typos, but not good enough to completely generate any program."
  },
  {
    "objectID": "labs/lab3/lab3.html#initial-attempt",
    "href": "labs/lab3/lab3.html#initial-attempt",
    "title": "Lab 3: Keypad Scanner",
    "section": "Initial Attempt",
    "text": "Initial Attempt\n\n\n\nFigure 11: Decoding FSM\n\n\n\n\n\nFigure 12: Debouncing FSM"
  },
  {
    "objectID": "labs/lab5/lab5.html",
    "href": "labs/lab5/lab5.html",
    "title": "Lab 5: Interrupts",
    "section": "",
    "text": "In this lab, we utilized the STM32L432KC MCU and a motor with a quadrature encoder (25GA-370) to determine the speed and direction of the revolution of the motor. This was done by utilizing CMSIS’ library of macros and structs created for the STM32L423xx chip, and by initializing and coding our own interrupts. We had two inputs at the GPIOs, one for the A encoder and one for the B encoder. The interrupts were triggered at both rising and falling edges of both signals, one for each encoder signal. The interrupts were designed to save timestamps, and with some logic, saved the number of edges since some last time, and was able to get the revolution and direction of the motor as it spun.\nLab Manual: E155 Lab 5 Instructions"
  },
  {
    "objectID": "labs/lab5/lab5.html#introduction",
    "href": "labs/lab5/lab5.html#introduction",
    "title": "Lab 5: Interrupts",
    "section": "",
    "text": "In this lab, we utilized the STM32L432KC MCU and a motor with a quadrature encoder (25GA-370) to determine the speed and direction of the revolution of the motor. This was done by utilizing CMSIS’ library of macros and structs created for the STM32L423xx chip, and by initializing and coding our own interrupts. We had two inputs at the GPIOs, one for the A encoder and one for the B encoder. The interrupts were triggered at both rising and falling edges of both signals, one for each encoder signal. The interrupts were designed to save timestamps, and with some logic, saved the number of edges since some last time, and was able to get the revolution and direction of the motor as it spun.\nLab Manual: E155 Lab 5 Instructions"
  },
  {
    "objectID": "labs/lab5/lab5.html#design-and-testing-methodology",
    "href": "labs/lab5/lab5.html#design-and-testing-methodology",
    "title": "Lab 5: Interrupts",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nTimer drivers from Lab 4 were utilized for reusability and modularity, but with the newly approved access to CMSIS and their prewritten library, it was necessary to delete all personalized structs and base addresses, along with some constants. Two timers were initialized to 1. record timestamps at which each pulse cycle’s edges were triggering the interrupts and 2. create delays between each velocity update with a PSC of 4000, since we were aiming for an update frequency of 1 Hz. Initialization of an interrupt was done by registering a route between GPIO and EXTI interrupt, unmasking the interrupt line, enabling both rising and falling triggers, and enabling the correct NVIC interrupt channel.\nInputs for the encoder signals were PA8 for encoder A and PA10 for encoder B. Both were part of GPIO Port A and as a part of the later GPIO pins, shared handlers across multiple pins. As a result, it was important to validate that it was that specific EXTI line that triggered the interrupt. The interrupts were each defined in EXTI9_5_IRQHandler and EXTI15_10_IRQHandler as each pin, PA8 and PA10, were each within the shared lines 5-9 and 10-15.\nSince this specific motor outputs 408 pulses per revolution (PPR) and we have a resolution of 4 edges per cycle from two signals, we can figure out the rotational velocity of the motor by counting the number of edges. We used the equation V = edge_count / (4 * 408). The direction was determined by comparing the states of the signals at each rising and falling edge, and came up with some logic.\n\n\n\nFigure 1: Direction logic"
  },
  {
    "objectID": "labs/lab5/lab5.html#technical-documentation",
    "href": "labs/lab5/lab5.html#technical-documentation",
    "title": "Lab 5: Interrupts",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for the project can be found in this GitHub repository.\n\nFlow Chart\n\n\n\nFigure 2: Flow Chart\n\n\nFigure 2 depicts the flow chart of the interrupt handler design on the MCU in conjunction with the timing with the rest of the program.\n\n\nSchematic\n\n\n\nFigure 3: Schematic\n\n\nFigure 3 depicts the physical schematic of the design."
  },
  {
    "objectID": "labs/lab5/lab5.html#results-and-discussion",
    "href": "labs/lab5/lab5.html#results-and-discussion",
    "title": "Lab 5: Interrupts",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\nOscilloscope\n\n\n\nFigure 4: Oscilloscope Trace for 2.52 V\n\n\n\n\n\nFigure 5: Oscilloscope Trace for 6.02 V\n\n\n\n\n\nFigure 6: Oscilloscope Trace for 9.97 V\n\n\nAttached are three oscilloscope traces displaying encoder signal A’s output when input with 2.52V, 6.02V, and 9.97V. By manually counting these edges, we can verify the velocity output at a specific time by comparing the hand-calculated velocity with the output velocity at the same voltage.\n2.52 V had a 232Hz encoder output as shown on the oscilloscope, which could be converted to a \\(232 / 408 = 0.568\\) rev/s calculation by hand. The program itself detected \\(0.569\\) rev/s. 8.15V hand-calculated was \\(577 / 408 = 1.414\\) rev/s and \\(1.418\\) rev/s detected. 9.93V: = \\(971 / 408 = 2.380\\) rev/s and \\(2.380\\) rev/s. Errors were minimal, usually to the thousandth degree, and all outputs were expected.\n\n\nManual Polling\nI did manual polling by removing the delay factor from the loop and calling the same update velocity function in another while loop. I toggled a separate output pin whenever the update velocity function to check how fast it would toggle, as in how fast the program would be able to manually function without detecting edges with interrupts. From Figure 7 below, I detected that that occurs at a 330 Hz frequency, which is much slower than around the 408 * 2.4 Hz that occurs at an input voltage of 10V.\n\n\n\nFigure 7: Oscope trace of polling"
  },
  {
    "objectID": "labs/lab5/lab5.html#conclusion",
    "href": "labs/lab5/lab5.html#conclusion",
    "title": "Lab 5: Interrupts",
    "section": "Conclusion",
    "text": "Conclusion\nThe design made in this lab successfully read the velocity of a motor by utilizing interrupts and detecting the maximum number of encoder signal edges possible for the highest resolution possible. Total hours worked: 12 hours."
  },
  {
    "objectID": "labs/lab5/lab5.html#ai-prototype-summary",
    "href": "labs/lab5/lab5.html#ai-prototype-summary",
    "title": "Lab 5: Interrupts",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\n\nAbriged Chat Log\n\nPrompt: What timers should I use on the STM32L432KC to generate frequencies ranging from 220Hz to 1kHz? What’s the best choice of timer if I want to easily connect it to a GPIO pin? What formulae are relevant, and what registers need to be set to configure them properly?\n\n\nRecommended Pin Connections: You should connect your encoder channels to a General-Purpose Timer (GPT) that supports encoder interface mode. TIM2 is a 32-bit timer available on the STM32L432KC, making it an excellent choice.\n\n\nChannel A PA0 TIM2_CH1 (Alternate Function) Encoder Phase 1 Input\nChannel B PA1 TIM2_CH2 (Alternate Function) Encoder Phase 2 Input\nIndex (Z) PB5 EXTI Line 5 Zero-position reference (Optional)\n\nEncoder Channels A and B are connected to the Timer peripherals (PA0/PA1). The Index (Z) Pulse, if available, is best handled by a regular External Interrupt (EXTI), as it only fires once per revolution. We will use PB5 as an example.\n\nTimer Setup (Conceptual Configuration): Before the interrupt handler can run, you must configure the peripherals. This typically involves setting GPIO Alternate Functions, enabling the timer clock, and setting the timer mode.\n\nI will provide a conceptual C code snippet showing the key register configuration steps, assuming a CMSIS (bare-metal) style, as this is closest to the hardware registers you’d manipulate.\n(Code attached)\n\nInterrupt Handler (TIM2_IRQHandler): The main logic for the quadrature encoder is to track the number of times the hardware counter overflows (goes from 0xFFFF to 0) or underflows (goes from 0 to 0xFFFF). This allows you to track a total count far exceeding the 16-bit limit of the counter register (2^16 = 65,536 pulses).\n\n(Code attached)\nHow the Timer Encoder Mode Works\n\nHardware Counting: The hardware timer (TIM2) constantly monitors the signals on PA0 (A) and PA1 (B). Based on the phase difference, it automatically increments or decrements the TIM2-&gt;CNT (Counter) register.\nRange Management: The counter is configured to run from 0 to 0xFFFF (65,535).\nInterrupt Trigger: When the count goes from 0xFFFF→0 (overflow, positive direction) or 0→0xFFFF (underflow, negative direction), the Update Interrupt Flag (UIF) is set, triggering the TIM2_IRQHandler.\nSoftware Extension: Inside the interrupt, we check the hardware direction flag (TIM2-&gt;CR1_DIR) and adjust the 32-bit software variable (total_encoder_pulses) by ±65,536.\nFinal Position: Your true, overall position is the sum of the software offset (total_encoder_pulses) and the current hardware count (TIM2-&gt;CNT).\nTotal Pulses=total_encoder_pulses+TIM2→CNT\n\n\n\nReflection\nI used Gemini’s 2.5-Flash model for this prototype. The two files provided built instantly, but had a difficult time integrating into the workflow that I had built. I think it made use of the CMSIS structs and macros well, but without the context of some of the GPIO pins I used, it needed some debugging to tweak everything so it worked. In the end, the direction stuff worked after some debugging but the revolutions was multiplied by a few terms up. I think the bot miscalculated some of the values it added and negated as underflow or overflow. But, the TIM initialization is very standard and easy to find off the internet, which is why it was probably easier for the LLM to fish that part out."
  },
  {
    "objectID": "labs/lab6/lab6.html",
    "href": "labs/lab6/lab6.html",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "",
    "text": "In this lab, we utilized a temperature sensor and an ESP8266 module that hosted a webserver to demonstrate the usage of the SPI protocol. The temperature sensor was controlled by the MCU through SPI, sending readings at various levels of precision back to the MCU, which then displayed the information to a simple HTML webpage. The webpage also allowed for simple control of an LED via UART.\nLab Manual: E155 Lab 6 Instructions"
  },
  {
    "objectID": "labs/lab6/lab6.html#introduction",
    "href": "labs/lab6/lab6.html#introduction",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "",
    "text": "In this lab, we utilized a temperature sensor and an ESP8266 module that hosted a webserver to demonstrate the usage of the SPI protocol. The temperature sensor was controlled by the MCU through SPI, sending readings at various levels of precision back to the MCU, which then displayed the information to a simple HTML webpage. The webpage also allowed for simple control of an LED via UART.\nLab Manual: E155 Lab 6 Instructions"
  },
  {
    "objectID": "labs/lab6/lab6.html#design-and-testing-methodology",
    "href": "labs/lab6/lab6.html#design-and-testing-methodology",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nI built an SPI library that contained initSPI() and spiSendReceive() functions, which respectively configured and enabled the SPI peripheral, and transmits a character (1 byte) over SPI and returns the received character. CMSIS standards were followed to the best of my ability, using pre-defined macros and _VAL2FLD() for any multi-bit values during configuration. spiSendRecieve() waits for the TXE flag to set to 1, which indicates an empty transmit buffer. Once it’s empty, it writes your specified byte (passed in to the function as a parameter) the 8-bit data register. We then wait for the RXNE flag to pop up, which indicates a full recieve buffer. This basically means we wait until we fully recieve a byte. We then read that byte from the data register, and cast it to a volatile character to correctly store it as an 8-bit integer. This works because SPI is full-duplex and both transmits and recieves a byte of information at the same time.\nI also built a DS1722 library based off its datasheet that contained initTempSensor(), getTemp(), and setPrecision(). These functions used the SPI interface to communicate to the sensor from the MCU. initTempSensor() only consisted of writing to address 0x80 for configuration and specifying continuous conversion mode via 0xEE. setPrecision() was also was just some if-else statements that was called via UART and took input from the buttons the user pressed on the webpage. The precision would be specified on the sensor by, again, writing to address 0x80 and specifying the precision values using values between 0xE0 to 0xE8, and higher precisions effectively took longer to convert.\nThe getTemp() function converted between the values of MSB and LSB and a valid temperature in degrees Celsius. As stated in the DS1722 datasheet, the MSB (in address 0x02) contained the sign bit and integer value of the temperature. The LSB (in address 0x01) contained the fractional bits at increments of 1/2^4=1/16=0.0625 degrees Celsius, but due the last 4 bits always being 0, it was necessary to divide by 4^8=256 to get the correct fractional value. As a result, the final equation for the temperature was \\(T = MSB + \\frac{LSB}{4^8}\\). The values for MSB and LSB were obtained by accessing the 0x02 address and sending a dummy byte to recieve its output, and doing the same with the 0x01 address for the LSB value.\nBuilding the webpage itself wasn’t so difficult since we were given a lot of starter code from the E155 GitHub Repository. I think all I did was just edit a little bit of the HTML and add in a couple strings to pass over UART. There was some basic logic to allow selecting precision, but really nothing to write home about. We connected to the ESP’s webpage by connecting to its WiFi access point and going to http://192.168.4.1/."
  },
  {
    "objectID": "labs/lab6/lab6.html#technical-documentation",
    "href": "labs/lab6/lab6.html#technical-documentation",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for the project can be found in this GitHub repository.\n\nSchematic\n\n\n\nFigure 1: Schematic\n\n\nFigure 1 depicts the physical schematic of the design. The layout is pretty simple, since the PB3, PB4, and PB5 pins on the board have built-in alternate functions as SPI’s SCK, SDO, and SDI pins respectively. All that was needed was to specify it in the code during initialization. The SERMODE pin on the DS1722 was connected to V_DD because a connection to V_DD specified a SPI interface standard, while a connection to GND would chose a 3-wire interface standard instead."
  },
  {
    "objectID": "labs/lab6/lab6.html#results-and-discussion",
    "href": "labs/lab6/lab6.html#results-and-discussion",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\nLogic Analyzer\n\n\n\nFigure 2: Logic Analyzer Trace during Read phase of SPI Transaction\n\n\nFigure 2 above is a sample SPI transaction from logic analyzer."
  },
  {
    "objectID": "labs/lab6/lab6.html#conclusion",
    "href": "labs/lab6/lab6.html#conclusion",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Conclusion",
    "text": "Conclusion\nThe design made in this lab successfully read temperatures through the DS1722 sensor and displayed them on a simple HTML website hosted on an ESP8266 module. The SPI protocol was initialized and utilized a send-recieve function to monitor changes. The UART protocol was also utilized to control a LED on the board. There was some confusion and unclear signals from the logic analyzer. Total hours worked: 14 hours."
  },
  {
    "objectID": "labs/lab6/lab6.html#ai-prototype-summary",
    "href": "labs/lab6/lab6.html#ai-prototype-summary",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\n\nPrompts\n\nPrompt 1: I’m making a web portal to interface with a temperature sensor. Create a HTML page that looks good and is intuitive to show the temperature, control an LED, and change the precision of the readout.\n\n\nPrompt 2: Write me a C function to carry out a SPI transaction to retrieve a temperature reading from a DS1722 sensor. Make use of CMSIS libraries for the STM32L432KC.\n\n/**\n * @brief Performs a 3-byte SPI transaction to read the 16-bit temperature from the DS1722 sensor.\n * * Protocol: [COMMAND: 0x01] [DUMMY] [DUMMY] results in [GARBAGE] [T_MSB] [T_LSB]\n * The raw 16-bit data is in Q12.4 format (12 integer bits, 4 fractional bits).\n * * @return float The temperature reading in degrees Celsius.\n */\nfloat getTemp(void){\n  uint8_t rx_msb, rx_lsb;\n  int16_t raw_temp;\n\n  // 1. Assert Chip Select (CS active high to start transaction)\n  digitalWrite(SPI_CS, PIO_HIGH);\n\n  // 2. Send Command Byte (0x01) to read T_MSB register. \n  // The first byte received here is garbage data from the command transmission.\n  spiSendReceive(DS1722_REG_TEMP_MSB);\n\n  // 3. Send Dummy Byte (0xFF) to clock out Temperature MSB\n  rx_msb = (uint8_t)spiSendReceive(0xFF);\n\n  // 4. Send Dummy Byte (0xFF) to clock out Temperature LSB\n  rx_lsb = (uint8_t)spiSendReceive(0xFF);\n\n  // 5. De-assert Chip Select (CS inactive low to end transaction)\n  digitalWrite(SPI_CS, PIO_LOW);\n\n  // 6. Combine MSB and LSB into a signed 16-bit integer\n  // The casting to int16_t is critical for correct handling of negative (two's complement) temperatures.\n  raw_temp = (int16_t)((rx_msb &lt;&lt; 8) | rx_lsb);\n\n  // 7. Convert raw value (Q12.4 fixed-point) to degrees Celsius (raw * 0.0625)\n  return (float)raw_temp * DS1722_TEMP_RESOLUTION;\n}\n\n\nReflection\nI used Gemini’s 2.5-Flash model for this prototype. Its first response to the prompt generated an HTML file with some JavaScript logic and styling to make it look nicer. However, as we were working on an MCU and needed to convert the HTML into string format, I had to ask it to create another version of the file that can fit with the structure of our project. Literally none of it worked though, even after like half an hour of debugging. The webserver kept throwing the Could not connect to the MCU. Please check your connections. (10 or fewer bytes were received from the processor.) error. Assuming that the string I was trying to pass in was too long, I tried to lengthen the tx_buffer variable to 2048, but that didn’t work either. It was also diffcult asking for a version of the code without giving it any context, so I tried passing in my main.c and DS1722.c, but all it did was break the formatting of the code. I would rate this process 1/10. I think it showed me some cool things you can do with HTML that I didn’t know about it beforehand, but the whole formatting issue got on my nerves and while it did built, did not get off the ground at all.\nFor the second prompt, it was able to utilize SPI just fine on the first try, but its logic was off and resulted in temperature values on the order of 1-2 degrees Celsius. The LLM edited my function getTemp() to have the msb and lsb values recorded right after each other instead of each address and reading after each operation. This, along with the bit-shift, could be the reason why the calculation isn’t being output properly."
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab, the E155 Development Board was assembled for use for the rest of the semester. Preliminary testing was done on both FPGA and MCU components of the board via simple given projects. The primary objective of this lab was to program the FPGA to take binary input from 4 switches and output patterns using 3 LEDs and a seven-segment display.\nOne of the LEDs was designed to blink at 2.4 Hz by dividing the onboard high-speed oscillator, used as a clock, from 24 MHz. The two other LEDs were each programmed by applying a XOR and AND gate using 2 inputs from the 4 switches, following a truth table given in the instructions. The seven-segment display was programmed to display distince hexadecimal values between 0 to F given a combination of 4 binary inputs through the same switches.\nLINK: E155 Lab 1 Instructions"
  },
  {
    "objectID": "labs/lab1/lab1.html#introduction",
    "href": "labs/lab1/lab1.html#introduction",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab, the E155 Development Board was assembled for use for the rest of the semester. Preliminary testing was done on both FPGA and MCU components of the board via simple given projects. The primary objective of this lab was to program the FPGA to take binary input from 4 switches and output patterns using 3 LEDs and a seven-segment display.\nOne of the LEDs was designed to blink at 2.4 Hz by dividing the onboard high-speed oscillator, used as a clock, from 24 MHz. The two other LEDs were each programmed by applying a XOR and AND gate using 2 inputs from the 4 switches, following a truth table given in the instructions. The seven-segment display was programmed to display distince hexadecimal values between 0 to F given a combination of 4 binary inputs through the same switches.\nLINK: E155 Lab 1 Instructions"
  },
  {
    "objectID": "labs/lab1/lab1.html#design-and-testing-methodology",
    "href": "labs/lab1/lab1.html#design-and-testing-methodology",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nFor the blinking LED, the onboard high-speed oscillator, named HSOSC as part of the iCE40 UltraPlus primitive library, was used to generate a 24 MHz oscillation acting as a clock signal. Utilizing a counterFor the blinking led, the onboard high-speed oscillator, named HSOSC as part of the iCE40 UltraPlus primitive library, was used to generate a 24 MHz oscillation acting as a clock signal. Aiming for a 2.4 Hz signal, the clock divider was devised to use a counter that, between values of 0-5,000,000, kept the LED off, and between 5,000,000-10,000,000 turned the LED on. This was designed by dividing the 24 MHz clock down to 2.4 Hz requires a counter that reaches 10,000,000, ensuring the LED blinks at the desired frequency with a single on-off cycle per period. Testing for the blinking LED was conducted by an oscilloscope, where one probe was connected to the GND on the FPGA and the other at the anode of the diode.\nThe other two LEDs were implemented by following the truth tables, as displayed below. These are adapted from the Lab 1 Instructions, as linked above.\n\n\n\ns[1]\ns[0]\nled[0]\n\n\n\n\n0\n0\n0\n\n\n0\n1\n1\n\n\n1\n0\n1\n\n\n1\n1\n0\n\n\n\n\n\n\ns[3]\ns[2]\nled[1]\n\n\n\n\n0\n0\n0\n\n\n0\n1\n0\n\n\n1\n0\n0\n\n\n1\n1\n1\n\n\n\nThese tables can effectively be reduced to led[0] being the result of an XOR gate of s[0] and s[1], and led[1] an AND gate of s[3] and s[2].\nThe seven-segment display was programmed by using combinational logic and case statements in the HDL. Considering the limited current draw of the LED segments, it was necessary to calculate and assign resistors to each segment. Following \\(V = IR\\) and consulting datasheets for the HDSP-511A display, it was determined that these displays would have a forward voltage of between 1.8 to 2.1 V, and current 5 to 20 mA. Following the supplied 3.3 V, the optimal resistance was calculated by: \\[\\begin{aligned}\nR &= \\frac{V}{I}\\\\\\\\\n&= \\frac{3.3 - 2}{5*10^{-3}} \\\\\\\\\n&= 260\\, \\Omega\n\\end{aligned}\\] Considering that the targeted current draw was on the lower end of 5mA, the resistor value was rounded down to 220\\(\\,\\Omega\\)."
  },
  {
    "objectID": "labs/lab1/lab1.html#technical-documentation",
    "href": "labs/lab1/lab1.html#technical-documentation",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for the project can be found in this GitHub repository.\n\nBlock Diagram\n\n\n\nFigure 1\n\n\nFigure 1 depicts the block diagram of the design. The top-level module lab1_mt instantiates two submodules within it, one for the LED logic, leds, and another for the seven segment logic, sev_seg. Within the leds module, the HSOSC module was utilized to create an int_osc clock that was fed into a clock divider (that used a counter).\n\n\nSchematic\n\n\n\nFigure 2\n\n\nFigure 2 depicts the physical schematic of the design. Internal pullup resistors of 100k\\(\\,\\Omega\\) were used to ensure that the active low switches and reset button were not floating. The LEDs were each connected to 1k\\(\\,\\Omega\\) resistors, and each cathode of the seven-segment display was connected to a 220\\(\\,\\Omega\\) grounded resistor."
  },
  {
    "objectID": "labs/lab1/lab1.html#results-and-discussion",
    "href": "labs/lab1/lab1.html#results-and-discussion",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\nVideo Demonstration\nThis video below demonstrates all possible configurations of the switches and consequently the values of the LED and seven-segment display.\n\n\n\nTestbench Simulation\n\n\n\nFigure 3\n\n\n\n\n\nFigure 4\n\n\n\n\n\nFigure 5\n\n\nThe design met all intended design objectives. Figure 3, 4, and 5 show screenshots of the QuestaSim simulation of the testbenches designed for each module. Figures 6, 7, and 8 below show screenshots of the terminal output of the testbench modules, confirming zero errors and successful simulation. One note— since the 2.4 Hz blinking LED is difficult to test for in the testbench, it was forced to 0 through the command force led[2] 0 before running the testbench.\n\n\n\nFigure 6\n\n\n\n\n\nFigure 7\n\n\n\n\n\nFigure 8\n\n\n\n\nOscilloscope Trace\n\n\n\nFigure 9\n\n\nFigure 9 shows a screenshot of an oscilloscope verifying the 2.42 Hz frequency of the LED."
  },
  {
    "objectID": "labs/lab1/lab1.html#conclusion",
    "href": "labs/lab1/lab1.html#conclusion",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Conclusion",
    "text": "Conclusion\nOverall, the design blinked an LED at 2.4 Hz using the onboard high-speed oscillator, changed the state of two other LEDs depending on the input of the four switches, following the logic of a given truth table. The seven segment display was wired and programmed with combinational logic to display a hexadecimal value given the binary input through the same four switches. Roughly 20 hours were spent working on this lab. I spent a couple of hours stuck on some bugs with a digitally controlled oscillator, which I ended up scrapping."
  },
  {
    "objectID": "labs/lab1/lab1.html#ai-prototype-summary",
    "href": "labs/lab1/lab1.html#ai-prototype-summary",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\n\n\nSummarized Log\n\nFirst Prompt: Write SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.\n\nThis SystemVerilog code provides a solution for blinking an LED at a specific frequency on a Lattice iCE40 UP5K FPGA. … The generated file, led_blinker.sv … instantiates the SB_HFOSC primitive to get the 48 MHz clock signal and then uses an always_ff block to implement a counter that toggles the led output every 12 million clock cycles, achieving the requested 2 Hz blink rate.\n\nSecond Prompt: ERROR: instantiating unknown module SB_HFOSC\n\n…This is a common issue because SB_HFOSC is a vendor-specific primitive for Lattice iCE40 FPGAs, not a standard SystemVerilog module.\nTo resolve this, you need to ensure your toolchain is correctly configured for the Lattice iCE40 family. This typically involves:\n\nUsing a synthesis tool like Yosys with the icepack or nextpnr backends.\nMaking sure the primitive library files for the iCE40 family are included in your project or synthesis script.\n\n\nThird Prompt: Try using HSOSC instead\n\nI have updated the led_blinker.sv file to use the HSOSC module instead of SB_HFOSC.\n\n\nReflection\nI used Gemini’s 2.5-Flash model for this prototype. Its complete and fixed output, as linked here, easily got to a synthesizable state after 3 prompts. The comments for this file were easy to read and explained a lot, if not too much. As a standalone prompt, the LLM was unable to tell what onboard specs and modules were available— it could only guess based on the massive data it’s been trained on that the most average chip would have a SB_HFOSC internal oscillator. Without the context that this FGPA contains a HSOSC module, it makes sense that it was unable to write instantly usable code. However, just by passing in the error and giving the model a possible alternative, it was able to easily modify the first piece of code into a file that synthesized.\nThere were no new idioms, at least, for me. It mostly used logic, parameter, and localparam, which I have been familiar with since E85. The instantiation of the resulting HSOSC module was a little less descriptive and seems to have been copied over from the SB_HFOSC instantiation idiom. This makes sense as the model seemed to simply switch out the module name, although it could become a cause of issue for other pairs of modules. The clock divider idiom was as usual. As a result, I would rate this code 8/10.\nIn the future, I would probably LLMs to generate SystemVerilog code if I knew what kind of hardware or idioms it would use, and specify that. As an extension of that, I would also need to know what kind of onboard modules and libraries the model could use to fulfill the prompt.\n\n\n\n\n\nFigure 10\n\n\nFigure 10 is the initial error message generated by Radiant’s Lattice LSE Synthesis."
  },
  {
    "objectID": "labs/lab7/lab7.html",
    "href": "labs/lab7/lab7.html",
    "title": "Lab 7: The Advanced Encryption Standard",
    "section": "",
    "text": "Nothing to see here just yet."
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "In this lab, the I/O pins on the FPGA board were efficiently utilized to drive a dual-seven segment display and five LEDs. This was achieved in combination with a time multiplexer and PNP transistors, considering the limited amount of usable pins. An HDL program was synthesized and mapped onto the FPGA memory, specifically built in a modular design to make reusability and testability tight and easy.\nThe goal of the lab was to have two 4-digit binary switches that each controlled a 7-segment display and its sum was presented as a binary 5-digit number through a row of 5 LEDs. The constraint was that there were only so many I/O pins, and so each of the segments of the dual seven-segment displays had to share a pin.\nLINK: E155 Lab 2 Instructions"
  },
  {
    "objectID": "labs/lab2/lab2.html#introduction",
    "href": "labs/lab2/lab2.html#introduction",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "In this lab, the I/O pins on the FPGA board were efficiently utilized to drive a dual-seven segment display and five LEDs. This was achieved in combination with a time multiplexer and PNP transistors, considering the limited amount of usable pins. An HDL program was synthesized and mapped onto the FPGA memory, specifically built in a modular design to make reusability and testability tight and easy.\nThe goal of the lab was to have two 4-digit binary switches that each controlled a 7-segment display and its sum was presented as a binary 5-digit number through a row of 5 LEDs. The constraint was that there were only so many I/O pins, and so each of the segments of the dual seven-segment displays had to share a pin.\nLINK: E155 Lab 2 Instructions"
  },
  {
    "objectID": "labs/lab2/lab2.html#design-and-testing-methodology",
    "href": "labs/lab2/lab2.html#design-and-testing-methodology",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nThe time-multiplexed dual seven-segment display was controlled by two enable signals and 7 segment values. Due to the shared resources of the wires and pins, it was necessary to oscillate the enable signals and the segment values, which each connected to the cathodes. The oscillation made sure that only one display would be on at one time, with the correct value. The enable signals each connected to the common anode of a seven-segment display, and if one was high, the other was low to ensure only one would be on. While each cathode shared a pin with the same cathode segment of the other display, the enable signals made sure that, again, only one display would be on, and that the number displayed would belong to the right display and switch.\nThe PNP transistor was utilized to source more current. With only a 8 mA current being sourced from each pin, it was not enough to power each cathode. As a result, the PNP transistors, given a 5 mA current from the base, or the pins, collected from the 3.3V voltage source and pulled a current enough to power the seven-segment display. The 5 mA current at the base was regulated by a resistor of 560 \\(\\,\\Omega\\). This was calculated via Ohm’s Law, \\(V = IR\\), where the voltage drop was calculated by \\(2.6 - 0\\). The \\(2.6 V\\) was found by negating the voltage drop from the 3.3 V emitter to the base, as given by \\(V_{BE(Sat)}\\) from the datasheet. The \\(0 V\\) was so due to the pin it connected to was grounded. As a result, \\((2.6 - 0) / 0.05 = 520\\,\\Omega\\), and the resistor used was a similar 510 \\(\\,\\Omega\\). The datasheet mentioned is linked here.\nThe resistors for the green LEDs on the breadboard were calculated by \\(V = IR\\) as well, but this time considering the forward voltage of the green LED, approximated as 2V at a lower current test condition. Considering the voltage drop and the target current of about 2 mA, \\(V = IR\\) reduces to \\(R = (3.3 - 2) / 0.02  = 0.65\\), or roughly 620 \\(\\,\\Omega\\).\nThe resistors for the red dual seven-segment display were chosen based on the datasheet linked here. Around a forward current of 5mA, the forward voltage of each LED segment drops down to 1.8V. Due to the \\(V_{CE(Sat)} = 0.7\\) at a current of 1 mA, there was a voltage drop from the emitter to the collector, resulting in the collector being at roughly 3 V. Knowing this, we can reconfigure Ohm’s Law to figure out the appropriate resistor. \\(R = V/I = (3.0 - 1.8) / 0.002 = 600\\), or roughly 620 \\(\\,\\Omega\\)."
  },
  {
    "objectID": "labs/lab2/lab2.html#technical-documentation",
    "href": "labs/lab2/lab2.html#technical-documentation",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for the project can be found in this GitHub repository.\n\nBlock Diagram\n\n\n\nFigure 1: Block diagram of the Lab 1 HDL code\n\n\nFigure 1 depicts the block diagram of the design. The top-level module lab2_mt instantiates four submodules within it. clk_gen houses the clk generation using the onboard high-speed oscillator through the HSOSC module. sev_seg_sel uses a clock divider to divide that oscillation down into a much slower frequency of 100 Hz. It creates two opposite, toggling enable signals for each dual seven-segment display. It also chooses which of the input switches to output as sw, depending on the enables. sev_seg is a module written for Lab 1 that was repurposed for this lab. It takes in some 4-bit binary switch input to output a 7-bit binary LED segment output. Finally, the led_adder is the module that takes in the 4-bit binary switch values to output their sum as a 5-bit binary LED value.\n\n\nSchematic\n\n\n\nFigure 2: Schematic of the external hardware used for Lab 2 design; doesn’t have the correct resistor values on it despite multiple updates and the right jpg being in the images folder.\n\n\nFigure 2 depicts the physical schematic of the design. The I/O pins were maxed out, with every single one of them connected to something. Two 4-digit DIP switches were used as the input for the program, with one soldered onto the PCB and another wired into the breadbord. A green LED each connected to an I/O pin, wired to the breadboard, and connected with a 620 \\(\\,\\Omega\\) current-limiting resistor. The reset was routed to a button on the board. Each cathode segment of the dual seven-segment display was connected to a pin, and the two common anodes of the display were connected from a source-generating PNP transistor, which were also connected to a pin each on the FPGA. Those pins were enabled and disabled by the seg1en and seg2en enable signals."
  },
  {
    "objectID": "labs/lab2/lab2.html#results-and-discussion",
    "href": "labs/lab2/lab2.html#results-and-discussion",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\nTestbench Simulation\n\n\n\nFigure 3: Waveform output of top-level module lab2_mt testbench\n\n\n\n\n\nFigure 4: Waveform output of module clk_gen testbench\n\n\n\n\n\nFigure 5: Waveform output of module sev_seg_sel testbench\n\n\n\n\n\nFigure 6: Waveform output of module sev_seg testbench\n\n\n\n\n\nFigure 7: Waveform output of module led_adder testbench\n\n\nThe design met all intended design objectives. Figures 3 to 7 show screenshots of the QuestaSim simulation of the testbenches designed for each module. Figures 8 to 12 below show screenshots of the terminal output of the testbench modules, confirming successful simulation and no errors.\nThe lab2_mt top-level module’s testbench was the most robust out of all testbenches. By generating a clk within the module, it was possible to apply a stimulus, check via assert of the seg output, and delay some time and then check again while expecting a differing output. With each delay, opposing seg1en and seg2en signals were expected as well. led was expected to stay the same for either signal as long as the stimulus stayed the same.\nThe clk_gen testbench was a relatively simple design, where it was verified that the clk was off at one point and on the other within a reasonable time frame considering its 6 MHz frequency. The sev_seg_sel testbench was similar to the lab2_mt testbench with delays to check timings and make sure the enable signals are switching, along with the seg values depending on which signal was enabled. sev_seg testbench was repurposed from Lab 1, with only minor naming convention changes applied. The led_adder testbench was simple as well, checking that the adder had the correct logic, and there was no need to consider timing at all.\n\n\n\nFigure 8: Terminal output of top-level module lab2_mt testbench\n\n\n\n\n\nFigure 9: Terminal output of module clk_gen outptestbenchut\n\n\n\n\n\nFigure 10: Terminal output of module sev_seg_sel testbench\n\n\n\n\n\nFigure 11: Terminal output of module sev_seg testbench\n\n\n\n\n\nFigure 12: Terminal output of module led_adder testbench"
  },
  {
    "objectID": "labs/lab2/lab2.html#conclusion",
    "href": "labs/lab2/lab2.html#conclusion",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Conclusion",
    "text": "Conclusion\nThe design made in this lab successfully operated a time-multiplexed, dual seven-segment display. They were operated by two DIP switches, which provided two 4-digit binary inputs. The sum of both numbers displayed were shown as a 5-digit binary output through green LEDs. The lab exercised knowledge in FPGA I/O pins, PNP transistor calculations, and clock timings. Total hours worked: 16 hours (Rough breakdown: 2 planning, 3 writing code, 5 testbench, 3 wiring, 3 portfolio + AI)."
  },
  {
    "objectID": "labs/lab2/lab2.html#ai-prototype-summary",
    "href": "labs/lab2/lab2.html#ai-prototype-summary",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\n\n\nLog (not including code)\n\nFirst Prompt: Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits.\n\nYou can time multiplex a single seven-segment decoder to drive two separate displays by rapidly switching between them. This approach uses a single decoder and associated circuitry to display different information on each display in an alternating fashion, relying on the persistence of human vision to create the illusion that both are lit simultaneously.\nThe SystemVerilog module seven_seg_mux implements a time multiplexer for two common anode seven-segment displays. It takes two 4-bit inputs (in_0, in_1), a clock signal (clk), and a reset signal (rst_n). It outputs the 7-bit decoded signal (anode_out) and a 2-bit anode select signal (anode_sel).\n\nSecond Prompt: Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.\n\nI can certainly help with that. Here is the SystemVerilog HDL to time multiplex a single seven-segment decoder. This module utilizes the sev_seg and leds modules you provided to drive two displays with different inputs. The time multiplexing is achieved by using a high-speed oscillator to rapidly switch between the two inputs.\nThis SystemVerilog file, seven_seg_mux.sv, contains a top-level module that demonstrates the time multiplexing. It instantiates the sev_seg module to handle the decoding and uses a clock signal from the leds module to rapidly switch between s1 and s2. It then drives the seg outputs and the an (anode) outputs to select which display is active at any given time.\n\n\nReflection\nI used Gemini’s 2.5-Flash model for this prototype. Its complete and fixed output for the first prompt is as linked here. It was synthesizable from the first prompt, where the two modules, seven_seg_mux and seven_seg_decoder, were provided and worked in sync with each other. The modules were not surprising at all, and closely replicated what we created for Lab 1. While I can’t be sure about the correctness of the combinational logic in seven_seg_decoder due to its lack of a linked datasheet or part number, this program did synthesize. The clock divider and selector logic in seven_seg_mux were very standard and easy to read. The instantiation was easier to read as a result of the labeled ports as well. I would rate this an 8/10 due to the lack of transparency about the combinational logic.\nThe second output can be found here. The modules leds and sev_seg were written by me for Lab 1, which was attached to the second prompt, and the module seven_seg_mux was generated by the LLM. There wasn’t anything totally new there either, other than a ternary operator that totally made sense but I hardly use (I know I should use it more). It was a little difficult to read becuase it had so many comments, but I think as a LLM and chatbot, it makes sense that there are a lot of redundant comments to explain its process. It was also able to mesh with my code that I provided pretty seamlessly, which was pretty cool (and scary). With synthesis being successful on the first try and decently clear code, I would rate this module a 9/10.\nAs a result of these LLM outputs, I think I could possibly use it to help write common and/or redundant idioms. However, I am still uncertain of its ability to read datasheets and figure out the connection between software and hardware, especially regarding pin numbers and naming conventions. While coding, it may be a good idea to consult the LLM to figure out typical idioms and removing small bugs and typos, but I doubt it has the ability to create its own block diagrams and architecture from the ground up, especially without any prior documentation provided."
  },
  {
    "objectID": "labs/lab4/lab4.html",
    "href": "labs/lab4/lab4.html",
    "title": "Lab 4: Digital Audio",
    "section": "",
    "text": "In this lab, we utilized the STM32L432KC MCU and a speaker to play a set of predetermined notes. This was done by creating our own drivers from scratch, making sure we configure and instantiate the utilizing two onboard timers. Both had the same system clock input of 80MHz, but each was configured so that they would count up to various values. One timer generated a square wave that output to a GPIO pin, therefore creating sounds out of the frequency, and the other created delays that changed the length of each note. There was some circuitry involved, where we hooked up an LM386 audio power amplifier to a speaker, which was controlled by both the MCU and a potentiometer.\nLINK: E155 Lab 4 Instructions"
  },
  {
    "objectID": "labs/lab4/lab4.html#introduction",
    "href": "labs/lab4/lab4.html#introduction",
    "title": "Lab 4: Digital Audio",
    "section": "",
    "text": "In this lab, we utilized the STM32L432KC MCU and a speaker to play a set of predetermined notes. This was done by creating our own drivers from scratch, making sure we configure and instantiate the utilizing two onboard timers. Both had the same system clock input of 80MHz, but each was configured so that they would count up to various values. One timer generated a square wave that output to a GPIO pin, therefore creating sounds out of the frequency, and the other created delays that changed the length of each note. There was some circuitry involved, where we hooked up an LM386 audio power amplifier to a speaker, which was controlled by both the MCU and a potentiometer.\nLINK: E155 Lab 4 Instructions"
  },
  {
    "objectID": "labs/lab4/lab4.html#design-and-testing-methodology",
    "href": "labs/lab4/lab4.html#design-and-testing-methodology",
    "title": "Lab 4: Digital Audio",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nTimer setup and initialization was done by a provided driver, where the multiple speed internal (MSI) clock, driven by an RC oscillator, input the onboard phase-locked loop (PLL). The maximum value of 80 MHz was chosen to drive both TIM15 and TIM16, some general-purpose timers. TIM16 generated a PWM to a GPIO, specifically pin A6, and TIM15 ensured the delay in between each change in note was accurate.\nPrescalar calculations were conducted via this Google Spreadsheet, where I found a combination of PSC and ARR values that correctly fit each timer’s needs. TIM15, as the delay clock, needed a maximum frequency of 1Hz and a minimum frequency of 500 Hz to be able to hold out for the longest duration. TIM16 had to drive a minimum of 220 Hz and a maximum of 1000 Hz to produce the correct frequencies of sound, as given by the spec sheet. PSC by design needs to stay constant for a timer no matter what. To make sure that ARR stayed within its register of up to 16 bits, some tweaking was involved. By following the equations \\(f_{CNT} = \\frac{SYSCLK}{PSC + 1}\\) and \\(f = \\frac{f_{CNT}}{ARR + 1}\\), it was possible to create a larger PSC of 4000 for TIM15 and a small PSC value of 20 for TIM16, which both suited ARR values to stay within the range.\n\n\n\nFigure 1: Prescaler Calculations"
  },
  {
    "objectID": "labs/lab4/lab4.html#technical-documentation",
    "href": "labs/lab4/lab4.html#technical-documentation",
    "title": "Lab 4: Digital Audio",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for the project can be found in this GitHub repository.\n\nSchematic\n\n\n\nFigure 2: Schematic\n\n\nFigure 2 depicts the physical schematic of the design. The design and components for the LM386 circuit was given by an example from its datasheet, specifically its Gain 50 circuit at Section 9.2.3."
  },
  {
    "objectID": "labs/lab4/lab4.html#results-and-discussion",
    "href": "labs/lab4/lab4.html#results-and-discussion",
    "title": "Lab 4: Digital Audio",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\nOscilloscope\n\n\n\nFigure 3: Oscilloscope Trace for 5 Hz, the frequency of C5\n\n\n\n\n\nFigure 4: Oscilloscope Trace for 220Hz\n\n\n\n\n\nFigure 5: Oscilloscope Trace for 1000Hz\n\n\nAttached are three oscilloscope traces displaying correct frequency behavior. Figure 3 is the trace shown when a note of C5 is being played as a part of Fur Elise. Figure 4 and 5 demonstrate the circuit’s propensity to generate at its minimum and maximum specified frequencies, at 220 Hz and 100 0Hz respectively."
  },
  {
    "objectID": "labs/lab4/lab4.html#conclusion",
    "href": "labs/lab4/lab4.html#conclusion",
    "title": "Lab 4: Digital Audio",
    "section": "Conclusion",
    "text": "Conclusion\nThe design made in this lab successfully operated a speaker, creating sounds that were discernable to the ear. The Fur Elise song and the score for Superman were used. Driver files were created from scratch, where timers were instantiated to take in a system clock input, and loaded different counter values to generate a square wave and durations at various frequencies. Circuitry involving the LM386 audio amplifier and potentiometer were physically created as well. Total hours worked: 12 hours."
  },
  {
    "objectID": "labs/lab4/lab4.html#ai-prototype-summary",
    "href": "labs/lab4/lab4.html#ai-prototype-summary",
    "title": "Lab 4: Digital Audio",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\n\nAbriged Chat Log\n\nFirst Prompt: What timers should I use on the STM32L432KC to generate frequencies ranging from 220Hz to 1kHz? What’s the best choice of timer if I want to easily connect it to a GPIO pin? What formulae are relevant, and what registers need to be set to configure them properly?\n\nGreat question — let’s walk through this systematically for the STM32L432KC (Cortex-M4, L4 series)…\nSummary: - Use TIM2 (32-bit, general-purpose, easy GPIO output on PA0/PA5/PA15). - \\(f_{OUT} = \\frac{f_{TIM}}{(PSC+1)(ARR+1)}\\) - Registers: PSC, ARR, CCRn, CCMRx, CCER, CR1. - Choose PSC=79 → gives 1 MHz timer tick → then ARR = 999–4544 gives 1 kHz–220 Hz.\n\nSecond Prompt: Using this reference manual of the MCU as context, what timers should I use on the STM32L432KC to generate frequencies ranging from 220Hz to 1kHz? What’s the best choice of timer if I want to easily connect it to a GPIO pin? What formulae are relevant, and what registers need to be set to configure them properly?\n\nI dug into the STM32L432KC reference manual you provided. Here’s how it breaks down for generating frequencies in the 220 Hz – 1 kHz range: …\nSummary: - Use TIM2 (best for simple frequency generation to a GPIO). - Formula: \\(f_{OUT} = \\frac{f_{TIM}}{(PSC+1)(ARR+1)}\\) - Configure PSC, ARR, CCRy, CCMRx, CCER, CR1. - Map timer channel to a GPIO AF in GPIOx_MODER + GPIOx_AFR.\n\n\nReflection\nI used ChatGPT’s GPT-4 model for this prototype. Both prompts recommended TIM1 and TIM2 for advanced-control PWM generation. Both made sure to enable the GPIO pins at alternate function. The one prompted with the reference manual declined to mention the BDTR flag. Neither reset the CNT register, which may or may not be necessary for implementation. However, overall, the setup for initialization seems fine and similar to what I had. It isn’t able to determine exactly which bit in the register or what values to change them to, but it is able to explain it clearly enough so that if you go into the datasheet, it is easy enough to find and code it.\nThe PSC values were accurate enough, since the LLM was able to correctly deduce that a 80MHz clock was input for the timers. Neither had the same ARR values, however. I think the model easily had accurate results even without the reference manual as the information for STM32L432KC is widely available online. I would rate these responses both a 9/10, since I think they are both probably really useful to know and can easily help implement. There’s still a need to look at the datasheet, which is probably better honestly since it forces users to understand exactly what they are doing."
  },
  {
    "objectID": "labs.html#lab-2-multiplexed-7-segment-display",
    "href": "labs.html#lab-2-multiplexed-7-segment-display",
    "title": "E155 Lab List",
    "section": "Lab 2: Multiplexed 7-Segment Display",
    "text": "Lab 2: Multiplexed 7-Segment Display"
  },
  {
    "objectID": "labs.html#lab-3-keypad-scanner",
    "href": "labs.html#lab-3-keypad-scanner",
    "title": "E155 Lab List",
    "section": "Lab 3: Keypad Scanner",
    "text": "Lab 3: Keypad Scanner"
  },
  {
    "objectID": "labs.html#lab-4-digital-audio",
    "href": "labs.html#lab-4-digital-audio",
    "title": "E155 Lab List",
    "section": "Lab 4: Digital Audio",
    "text": "Lab 4: Digital Audio"
  },
  {
    "objectID": "labs.html#lab-5-interrupts",
    "href": "labs.html#lab-5-interrupts",
    "title": "E155 Lab List",
    "section": "Lab 5: Interrupts",
    "text": "Lab 5: Interrupts"
  },
  {
    "objectID": "labs.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "href": "labs.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "title": "E155 Lab List",
    "section": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "text": "Lab 6: The Internet of Things and Serial Peripheral Interface"
  },
  {
    "objectID": "labs.html#lab-7-the-advanced-encryption-standard",
    "href": "labs.html#lab-7-the-advanced-encryption-standard",
    "title": "E155 Lab List",
    "section": "Lab 7: The Advanced Encryption Standard",
    "text": "Lab 7: The Advanced Encryption Standard"
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "E155 Resources",
    "section": "",
    "text": "Link to E155 Course Webpage"
  }
]