[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Initial Reflection\n\n\nGoals for this Semester in MicroPs\n\n\n\n\n\nAug 26, 2025\n\n\nMayu Tatsumi\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Mayu Tatsumi is a junior studying Engineering at Harvey Mudd College. She is interested in working in the camera and lighting industries and would like to become involved as an electrical engineer. She has prior experience working as a Systems Control intern specifically working on embedded systems and writing firmware. Outside of engineering, she is interested in movie & TV production, Formula 1, and gaming.\nThis is a Quarto website. To learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "Initial Reflection",
    "section": "",
    "text": "I had a blast this summer working as a Systems Control intern at a company working on some embedded systems for their robot. I mostly worked off what my mentor taught me and what I could soak up from the datasheets and user manuals, so I’m excited to get more formal and grounded education in this field.\nFor this semester, I’m determined to keep myself focused and engaged in class. I’ll write everything on paper since we’re going chalkboard method and keep all my devices in my bag unless I need to. I’ve found out that (surprise!) I actually do learn more via paper and pen, so I’ll try my best to stay locked in and get the most out of this class. I definitely will also review what I’ve learned in E85 since it’s been a while.\nI also want to technically improve my soldering skills and generally working with my hands when it comes to electronics. I had to do a lot of manually soldering and crimping parts together over the summer as well, and I found I had some trouble with it so I want to take this chance as a moment to improve for the future. I’ll have to make some time and take advantage of Mudd’s resources to practice and make perfect."
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "Lab 3: Keypad Scanner",
    "section": "",
    "text": "Nothing to see here just yet."
  },
  {
    "objectID": "labs/lab5/lab5.html",
    "href": "labs/lab5/lab5.html",
    "title": "Lab 5: Interrupts",
    "section": "",
    "text": "Nothing to see here just yet."
  },
  {
    "objectID": "labs/lab6/lab6.html",
    "href": "labs/lab6/lab6.html",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "",
    "text": "Nothing to see here just yet."
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab, the E155 Development Board was assembled for use for the rest of the semester. Preliminary testing was done on both FPGA and MCU components of the board via simple given projects. The primary objective of this lab was to program the FPGA to take binary input from 4 switches and output patterns using 3 LEDs and a seven-segment display.\nOne of the LEDs was designed to blink at 2.4 Hz by dividing the onboard high-speed oscillator, used as a clock, from 24 MHz. The two other LEDs were each programmed by applying a XOR and AND gate using 2 inputs from the 4 switches, following a truth table given in the instructions. The seven-segment display was programmed to display distince hexadecimal values between 0 to F given a combination of 4 binary inputs through the same switches.\nLINK: E155 Lab 1 Instructions"
  },
  {
    "objectID": "labs/lab1/lab1.html#introduction",
    "href": "labs/lab1/lab1.html#introduction",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab, the E155 Development Board was assembled for use for the rest of the semester. Preliminary testing was done on both FPGA and MCU components of the board via simple given projects. The primary objective of this lab was to program the FPGA to take binary input from 4 switches and output patterns using 3 LEDs and a seven-segment display.\nOne of the LEDs was designed to blink at 2.4 Hz by dividing the onboard high-speed oscillator, used as a clock, from 24 MHz. The two other LEDs were each programmed by applying a XOR and AND gate using 2 inputs from the 4 switches, following a truth table given in the instructions. The seven-segment display was programmed to display distince hexadecimal values between 0 to F given a combination of 4 binary inputs through the same switches.\nLINK: E155 Lab 1 Instructions"
  },
  {
    "objectID": "labs/lab1/lab1.html#design-and-testing-methodology",
    "href": "labs/lab1/lab1.html#design-and-testing-methodology",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nFor the blinking LED, the onboard high-speed oscillator, named HSOSC as part of the iCE40 UltraPlus primitive library, was used to generate a 24 MHz oscillation acting as a clock signal. Utilizing a counterFor the blinking led, the onboard high-speed oscillator, named HSOSC as part of the iCE40 UltraPlus primitive library, was used to generate a 24 MHz oscillation acting as a clock signal. Aiming for a 2.4 Hz signal, the clock divider was devised to use a counter that, between values of 0-5,000,000, kept the LED off, and between 5,000,000-10,000,000 turned the LED on. This was designed by dividing the 24 MHz clock down to 2.4 Hz requires a counter that reaches 10,000,000, ensuring the LED blinks at the desired frequency with a single on-off cycle per period. Testing for the blinking LED was conducted by an oscilloscope, where one probe was connected to the GND on the FPGA and the other at the anode of the diode.\nThe other two LEDs were implemented by following the truth tables, as displayed below. These are adapted from the Lab 1 Instructions, as linked above.\n\n\n\ns[1]\ns[0]\nled[0]\n\n\n\n\n0\n0\n0\n\n\n0\n1\n1\n\n\n1\n0\n1\n\n\n1\n1\n0\n\n\n\n\n\n\ns[3]\ns[2]\nled[1]\n\n\n\n\n0\n0\n0\n\n\n0\n1\n0\n\n\n1\n0\n0\n\n\n1\n1\n1\n\n\n\nThese tables can effectively be reduced to led[0] being the result of an XOR gate of s[0] and s[1], and led[1] an AND gate of s[3] and s[2].\nThe seven-segment display was programmed by using combinational logic and case statements in the HDL. Considering the limited current draw of the LED segments, it was necessary to calculate and assign resistors to each segment. Following \\(V = IR\\) and consulting datasheets for the HDSP-511A display, it was determined that these displays would have a forward voltage of between 1.8 to 2.1 V, and current 5 to 20 mA. Following the supplied 3.3 V, the optimal resistance was calculated by: \\[\\begin{aligned}\nR &= \\frac{V}{I}\\\\\\\\\n&= \\frac{3.3 - 2}{5*10^{-3}} \\\\\\\\\n&= 260\\, \\Omega\n\\end{aligned}\\] Considering that the targeted current draw was on the lower end of 5mA, the resistor value was rounded down to 220\\(\\,\\Omega\\)."
  },
  {
    "objectID": "labs/lab1/lab1.html#technical-documentation",
    "href": "labs/lab1/lab1.html#technical-documentation",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for the project can be found in this GitHub repository.\n\nBlock Diagram\n\n\n\nFigure 1\n\n\nFigure 1 depicts the block diagram of the design. The top-level module lab1_mt instantiates two submodules within it, one for the LED logic, leds, and another for the seven segment logic, sev_seg. Within the leds module, the HSOSC module was utilized to create an int_osc clock that was fed into a clock divider (that used a counter).\n\n\nSchematic\n\n\n\nFigure 2\n\n\nFigure 2 depicts the physical schematic of the design. Internal pullup resistors of 100k\\(\\,\\Omega\\) were used to ensure that the active low switches and reset button were not floating. The LEDs were each connected to 1k\\(\\,\\Omega\\) resistors, and each cathode of the seven-segment display was connected to a 220\\(\\,\\Omega\\) grounded resistor."
  },
  {
    "objectID": "labs/lab1/lab1.html#results-and-discussion",
    "href": "labs/lab1/lab1.html#results-and-discussion",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\nVideo Demonstration\nThis video below demonstrates all possible configurations of the switches and consequently the values of the LED and seven-segment display.\n\n\n\nTestbench Simulation\n\n\n\nFigure 3\n\n\n\n\n\nFigure 4\n\n\n\n\n\nFigure 5\n\n\nThe design met all intended design objectives. Figure 3, 4, and 5 show screenshots of the QuestaSim simulation of the testbenches designed for each module. Figures 6, 7, and 8 below show screenshots of the terminal output of the testbench modules, confirming zero errors and successful simulation. One note— since the 2.4 Hz blinking LED is difficult to test for in the testbench, it was forced to 0 through the command force led[2] 0 before running the testbench.\n\n\n\nFigure 6\n\n\n\n\n\nFigure 7\n\n\n\n\n\nFigure 8\n\n\n\n\nOscilloscope Trace\n\n\n\nFigure 9\n\n\nFigure 9 shows a screenshot of an oscilloscope verifying the 2.42 Hz frequency of the LED."
  },
  {
    "objectID": "labs/lab1/lab1.html#conclusion",
    "href": "labs/lab1/lab1.html#conclusion",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Conclusion",
    "text": "Conclusion\nOverall, the design blinked an LED at 2.4 Hz using the onboard high-speed oscillator, changed the state of two other LEDs depending on the input of the four switches, following the logic of a given truth table. The seven segment display was wired and programmed with combinational logic to display a hexadecimal value given the binary input through the same four switches. Roughly 20 hours were spent working on this lab. I spent a couple of hours stuck on some bugs with a digitally controlled oscillator, which I ended up scrapping."
  },
  {
    "objectID": "labs/lab1/lab1.html#ai-prototype-summary",
    "href": "labs/lab1/lab1.html#ai-prototype-summary",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\n\n\nSummarized Log\n\nFirst Prompt: Write SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.\n\nThis SystemVerilog code provides a solution for blinking an LED at a specific frequency on a Lattice iCE40 UP5K FPGA. … The generated file, led_blinker.sv … instantiates the SB_HFOSC primitive to get the 48 MHz clock signal and then uses an always_ff block to implement a counter that toggles the led output every 12 million clock cycles, achieving the requested 2 Hz blink rate.\n\nSecond Prompt: ERROR: instantiating unknown module SB_HFOSC\n\n…This is a common issue because SB_HFOSC is a vendor-specific primitive for Lattice iCE40 FPGAs, not a standard SystemVerilog module.\nTo resolve this, you need to ensure your toolchain is correctly configured for the Lattice iCE40 family. This typically involves:\n\nUsing a synthesis tool like Yosys with the icepack or nextpnr backends.\nMaking sure the primitive library files for the iCE40 family are included in your project or synthesis script.\n\n\nThird Prompt: Try using HSOSC instead\n\nI have updated the led_blinker.sv file to use the HSOSC module instead of SB_HFOSC.\n\n\nReflection\nI used Gemini’s 2.5-Flash model for this prototype. Its complete and fixed output, as linked here, easily got to a synthesizable state after 3 prompts. The comments for this file were easy to read and explained a lot, if not too much. As a standalone prompt, the LLM was unable to tell what onboard specs and modules were available— it could only guess based on the massive data it’s been trained on that the most average chip would have a SB_HFOSC internal oscillator. Without the context that this FGPA contains a HSOSC module, it makes sense that it was unable to write instantly usable code. However, just by passing in the error and giving the model a possible alternative, it was able to easily modify the first piece of code into a file that synthesized.\nThere were no new idioms, at least, for me. It mostly used logic, parameter, and localparam, which I have been familiar with since E85. The instantiation of the resulting HSOSC module was a little less descriptive and seems to have been copied over from the SB_HFOSC instantiation idiom. This makes sense as the model seemed to simply switch out the module name, although it could become a cause of issue for other pairs of modules. The clock divider idiom was as usual. As a result, I would rate this code 8/10.\nIn the future, I would probably LLMs to generate SystemVerilog code if I knew what kind of hardware or idioms it would use, and specify that. As an extension of that, I would also need to know what kind of onboard modules and libraries the model could use to fulfill the prompt.\n\n\n\n\n\nFigure 10\n\n\nFigure 10 is the initial error message generated by Radiant’s Lattice LSE Synthesis."
  },
  {
    "objectID": "labs/lab7/lab7.html",
    "href": "labs/lab7/lab7.html",
    "title": "Lab 7: The Advanced Encryption Standard",
    "section": "",
    "text": "Nothing to see here just yet."
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "Nothing to see here just yet."
  },
  {
    "objectID": "labs/lab4/lab4.html",
    "href": "labs/lab4/lab4.html",
    "title": "Lab 4: Digital Audio",
    "section": "",
    "text": "Nothing to see here just yet."
  },
  {
    "objectID": "labs.html#lab-2-multiplexed-7-segment-display",
    "href": "labs.html#lab-2-multiplexed-7-segment-display",
    "title": "E155 Lab List",
    "section": "Lab 2: Multiplexed 7-Segment Display",
    "text": "Lab 2: Multiplexed 7-Segment Display"
  },
  {
    "objectID": "labs.html#lab-3-keypad-scanner",
    "href": "labs.html#lab-3-keypad-scanner",
    "title": "E155 Lab List",
    "section": "Lab 3: Keypad Scanner",
    "text": "Lab 3: Keypad Scanner"
  },
  {
    "objectID": "labs.html#lab-4-digital-audio",
    "href": "labs.html#lab-4-digital-audio",
    "title": "E155 Lab List",
    "section": "Lab 4: Digital Audio",
    "text": "Lab 4: Digital Audio"
  },
  {
    "objectID": "labs.html#lab-5-interrupts",
    "href": "labs.html#lab-5-interrupts",
    "title": "E155 Lab List",
    "section": "Lab 5: Interrupts",
    "text": "Lab 5: Interrupts"
  },
  {
    "objectID": "labs.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "href": "labs.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "title": "E155 Lab List",
    "section": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "text": "Lab 6: The Internet of Things and Serial Peripheral Interface"
  },
  {
    "objectID": "labs.html#lab-7-the-advanced-encryption-standard",
    "href": "labs.html#lab-7-the-advanced-encryption-standard",
    "title": "E155 Lab List",
    "section": "Lab 7: The Advanced Encryption Standard",
    "text": "Lab 7: The Advanced Encryption Standard"
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "E155 Resources",
    "section": "",
    "text": "Link to E155 Course Webpage"
  }
]